
--  PEGASOFT SOCKETS
--
-- Linux/*NIX basic operating system file and socket routines.  The purpose
-- of this package is to work around the differences between C and Ada
-- strings, hide the worst C-specific details and to add exception handling.
-----------------------------------------------------------------------------
pragma ada_2005;

with system.address_to_access_conversions,
     interfaces.c;
use  interfaces.c;

-- system.os_constants is automatically generated by GCC from your various
-- /usr/include C files.  They contain standard constants like O_TRUNC and
-- SOCK_STREAM, error names, etc.  This is a non-standard library and is
-- not supposed to be with'ed but you may try to use it if you can't find
-- values yourself.
--
-- If you comment this out, comment out the asserts in the package
-- initialization block as well.

pragma warnings( off );
with system.os_constants;
pragma warnings( on );

package os_defs is

-----------------------------------------------------------------------------
--  OS DEFINITION BINDINGS
--
-- Most of these were taken from my Business Shell.  The values are for
-- Linux.  Check your operating system and adjust these values accordingly.
-- Constants are usually found in /usr/include C header file.  Function
-- types can be checked using the man manual command.
-----------------------------------------------------------------------------

-- Errors

function C_pegasock_errno return integer;
pragma import( C, C_pegasock_errno, "C_pegasock_errno" );
procedure C_pegasock_reset_errno;
pragma import( C, C_pegasock_reset_errno, "C_pegasock_reset_errno" );
--  Gnat 5.x won't import status properly.  These C wrapper functions are
-- a workaround and are located in c_os.c

type anErrorBuffer is new string( 1..256 );
type anErrorPtr is access all anErrorBuffer;

function strerror( i : integer ) return anErrorPtr;
pragma import( C, strerror );
-- return an error message for error code i

EINTR       : constant integer := 4;      -- Interrupted system call
EAGAIN      : constant integer := 11;     -- No more processes (or EWOULD
EWOULDBLOCK : constant integer := 11;     -- Same as EAGAIN in Linux
EALREADY    : constant integer := 114;    -- socket busy
EINPROGRESS : constant integer := 115;    -- socket busy

-- Files

type anOpenFlag is new integer;
O_RDONLY   : constant anOpenFlag := 0;
O_WRONLY   : constant anOpenFlag := 1;
O_CREAT    : constant anOpenFLag := 8#100#;
O_TRUNC    : constant anOpenFlag := 8#1000#;
O_APPEND   : constant anOpenFlag := 8#2000#;
O_NONBLOCK : constant anOpenFlag := 8#4000#;
O_SYNC     : constant anOpenFlag := 8#10000#;
--O_NOATIME  : constant anOpenFlag := 8#1000000#;

-- /usr/include/bits/fcntl.h

procedure read( result : out size_t; fd : int; buffer : in system.address;
  count : size_t );
pragma import( C, read );
pragma import_valued_procedure( read );

procedure write( result : out size_t; fd : int; buffer : in system.address;
  count : size_t );
pragma import( C, write );
pragma import_valued_procedure( write );

function open( path : string; flags : anOpenFlag; mode : integer ) return int;
pragma import( C, open );

function close( fd : int ) return int;
pragma import( C, close );

function fdatasync( fd : int ) return int;
pragma import( C, fdatasync );
-- some *NIXes can use fsync() instead

function unlink( s : string ) return int;
pragma import( C, unlink );

-- Networking
--
-- Socket related definitions
--
-- These are the kernel calls and types we need to create and use a basic
-- TCP/IP (Internet) socket.
--
-- type aSocketFD is new aBufferedFile;
-- in gnat 3.13 & 3.14 gives "Valued_Procedure has no effect for convention Ada"
-- pragma convention will not override this message, so we'll resort to this:
------------------------------------------------------------------------------

--type aSocketFD is new integer;
-- a socket file descriptor is an integer -- man socket
-- make this a new integer for strong typing purposes

type aProtocolFamily is new unsigned_short;
AF_INET : constant aProtocolFamily := 2;

-- Internet protocol PF_Net defined as 2 in
-- /usr/include/sys/socket.h
-- Make this a new integer for strong typing purposes

type aSocketType is new int;
SOCK_STREAM : constant aSocketType := 1;
SOCK_NONBLOCK : constant aSocketType := 8#4000#;

-- this is for a steady connection.  Defined as 1 in
-- /usr/include/linux/socket.h or in /usr/include/bits/socket.h
-- Make this a new integer for strong typing purposes

type aNetProtocol is new int;
IPPROTO_TCP : constant aNetProtocol := 6;

-- The number of the TCP/IP protocol
-- TCP protocol defined as 6 in /etc/protocols
-- See man 5 protocols
-- Make this a new integer for strong typing purposes

type aNetDomain is new integer;
PF_INET : constant aNetDomain := 2;

-- The number of the Internet domain
-- Make this a new integer for strong typing purposes

type aInAddr is record
     addr : unsigned := 0;
end record;
pragma warnings( off ); -- hide warning about wasted bits
for aInAddr'size use 96;
pragma warnings( off );
-- A sockaddr_in record is defined as 16 bytes long (or 96 bits)
-- Request Ada to use 16 bytes to represent this record

type aSocketAddr is record
     family : aProtocolFamily := AF_INET; -- protocol (AF_INET for TCP/IP)
     port   : unsigned_short := 0;  -- the port number (eg 80 for web)
     ip     : aInAddr;              -- IP number
end record;
-- an Internet socket address
-- defined in /usr/src/linux/include/linux/socket.h
-- and /usr/src/linux/include/linux/in.h

function socket( domain   : aNetDomain;
                 stype    : aSocketType;
                 protocol : aNetProtocol )
return int;
pragma import( C, socket );
-- initialize a communication socket.  -1 if error

procedure bind( result : out int; sockfd : int;
  sa : in out aSocketAddr; addrlen : int );
pragma import( C, bind );
pragma import_valued_procedure( bind );
-- give socket a name. 0 if successful

procedure Connect( result : out int; socket : int;
  sa : in out aSocketAddr; addrlen : int );
pragma import( C, connect );
pragma import_valued_procedure( connect );
-- connect to a (Internet) server.  0 if successful

package addrListPtrs is new System.Address_To_Access_Conversions( System.Address
 );

-- We need to use C pointers with the address list because this is
-- a pointer to a pointer in C.  This will allow us to dereference
-- the C pointers in Ada.

subtype addrListPtr is System.Address;
-- easier to read than System.Address

type aHostEnt is record
     h_name      : System.Address;    -- pointer to offical name of host
     h_aliases   : System.Address;    -- pointer to alias list
     h_addrtype  : int     := 0;      -- host address type (PF_INET)
     h_length    : int     := 0;      -- length of address
     h_addr_list : addrListPtr;       -- pointer to list IP addresses
                                      -- we only want first one
end record;
-- defined in man gethostbyname

package HEptrs is new System.Address_To_Access_Conversions( aHostEnt );
-- Again, we need to work with C pointers here
subtype aHEptr is System.Address;
-- and this is easier to read
use HEptrs;
-- use makes = (equals) visible

function getHostByName( cname : string ) return aHEptr;
pragma import( C, getHostByName );
-- look up a host by it's name, returning the IP number

function htons( s : unsigned_short ) return unsigned_short;
pragma import( C, htons );
-- acronym: host to network short -- on Intel x86 platforms,
-- switches the byte order on a short integer to the network
-- Most Significant Byte first standard of the Internet

procedure memcpy( dest, src : System.Address; numbytes : int );
pragma import( C, memcpy);
-- Copies bytes from one C pointer to another.  We could probably
-- use unchecked_conversion, but the C examples use this.

-----------------------------------------------------------------------------
-- UTILITIES
-----------------------------------------------------------------------------
--
function OSerror( e : integer ) return string;
-- return an OS error message for error number e

end os_defs;
