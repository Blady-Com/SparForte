<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Ken Burtch">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.7-10 i686) [Netscape]">
   <title>Business Shell (BUSH) Guide</title>
</head>
<body bgcolor="#CCCC99">

<center>
<img src="bush_title_bar.gif" alt="[BUSH User Guide]" width="710" height="99">
</center>
<!-- h2>
<font color="#777700">
Bush Guide: Part 5 - BUSH Hackers Guide</font></h2 -->

<table summary="menu" border="0" cellpadding="0" cellspacing="0"
 width="100%">
<tr>
<td valign="bottom" bgcolor="white">&nbsp;</td>
</tr><tr>
<td valign="bottom" bgcolor="white">
<table summary="menu" border="0" cellpadding="0" cellspacing="0"
 width="100%">
  <tbody>
    <tr bgcolor="white">
      <td align="center"><a href="http://www.pegasoft.ca/bush.html">Home Page</a></td>
      <td align="center"><a href="bushintro.html">Introduction</a></td>
      <td align="center"><a href="bushtutorial.html">Tutorials</a></td>
      <td align="center"><a href="bushref.html">Reference</a></td>
      <td align="center"><a href="bushpackages.html">Packages</a></td>
      <td valign="bottom" align="center" bgcolor="#CCCC99"><font size="+1" color="#777700"><b>Hacking</b></font></td>
    </tr>
  </tbody>
</table>
</td>
</tr>
</table>

<ul>
  <li><a href="#5.1">5.1 BUSH Structure</a></li>
  <li><a href="#5.2">5.2 Porting BUSH to UNIX</a></li>
  <li><a href="#5.3">5.3 Porting BUSH to MS-DOS or Windows</a></li>
  <li><a href="#5.4">5.4 Adding New Built-in Packages</a></li>
</ul>
<hr>This part of the guide contains detailed descriptions of how BUSH
is structured, how to add packages and how to port BUSH.&nbsp; The information
in this section is subject to change between different versions of BUSH
(and may be out of date).
<br>&nbsp;
<h3>
<a NAME="5.1"></a><font color="#777700">5.1 BUSH Structure</font></h3>
BUSH is written in GCC Ada (GNAT) and GCC&nbsp;C.
<p>Files named ".ads" are Ada package specifications.&nbsp; They contain
the definitions of package functions (like a C&nbsp;header file) and document
the functions inside a package.
<p>Files named ".adb" are Ada package bodies.&nbsp; They contain the actual
implementation of the package (like a C ".c" file).
<p>Except for the main program (bush.adb), all other packages have a specification
and a body.
<p>The BUSH project files can be divided up into 4 layers which build one
on top of another:
<br>&nbsp;
<ul>
<li>
<b>utilities</b> - packages containing commonly used functions shared by
several packages</li>

<li>
<b>scanner</b> - packages implement the lexical scanner.&nbsp; This part
of BUSH compiles the byte code, maintains the symbol table, and interprets
the script as a series of "tokens".</li>

<li>
<b>parser</b> - packages that implement the BUSH features and check for
syntactic and semantic errors.&nbsp; This part of BUSH "runs" the script
and reports error messages.</li>

<li>
<b>main program</b></li>
</ul>

<p><br>Utility Packages
<br>&nbsp;
<ul>
<li>
<b>bush_os</b> - the package containing binding to your operating system as chosen
by the configure script.  That is, it's a copy of bush_linux, bush_freebsd, etc.
There are several child packages: support for the O/S terminal (bush_os.tty),
support for the SDL library (bush_os.sdl) and executing programs (bush_os.exec).</li>

<li>
<b>bush_linux</b> - bush_os for Linux</li>

<li>
<b>bush_freebsd</b> - bush_os for FreeBSD</li>

<li>
<b>world</b> - the symbol table and global type declarations</li>

<li>
<b>gen_list</b> - a generic (template) package for single-direction linked
lists.</li>

<li>
<b>script_io</b> - routines to read a script file</li>

<li>
<b>user_io</b> - routines to read the keyboard and print to the screen.&nbsp;
Also implements the emacs and vi editing modes.</li>

<li>
<b>signal_flags</b> - interface to the C signal handlers.</li>

<li>
<b>c_os</b> - support functions written in the C language.&nbsp; In particular,
the signal handlers are written in C.</li>
</ul>

<p><br>Scanner Packages
<br>&nbsp;
<ul>
<li>
<b>jobs</b> - runs an operating system command.&nbsp; That is, forks
off a separate process, sets up standard input, output and error, and starts
the command running.&nbsp; Also implements BUSH job control.</li>

<li>
<b>scanner</b> - contains the main body of the scanner.&nbsp; Includes
identifier declarations, byte code compiler,&nbsp; tokenizing functions,
and error reproting.</li>

<li>
<b>scanner-calendar </b>- implementation of Ada.Calendar package.&nbsp;
(This is the GCC Ada calendar package with the time type as non-private
so it can be used from BUSH.)</li>
</ul>

<p><br>Parser Packages
<br>&nbsp;
<ul>
<li>
<b>builtins</b> - implementation of built-in shell commands.&nbsp; That
is, "cd", "pwd", "history" and "env".</li>

<li>
<b>parser</b> - implements the core AdaScript language and Text_IO functions.&nbsp;
Handles syntax checking, running scripts and running commands at the BUSH
command prompt.</li>

<li>
<b>parser_aux</b> - utility functions soley for the parser.&nbsp; For example,
working with file_type variables, creating temp files and opening network
sockets.</li>

<li>
<b>parser_cal</b> - implementation of the built-in calendar package; interface
to scanner-calendar package.</li>

<li>
<b>parser_cgi </b>- implementation of the built-in cgi package; interface
to the AdaCGI package</li>

<li>
<b>parser_cmd</b> -&nbsp; implementation of the built-in command_line package,
interface to Ada.Command_Line</li>

<li>
<b>parser_db</b> - implementation of the built-in db package; interface
to Warren Gay's APQ Postgres binding</li>

<li>
<b>parser_lock </b>- implementation of the built-in lock_files package,
interface to GNAT.Lock_Files</li>

<li>
<b>parser_numerics</b> - implementation of the built-in numerics package,
interface to various Ada numeric features/packages</li>

<li>
<b>parser_strings</b> - implementation of the built-in strings package,
interface to various Ada string features/packages</li>

<li>
<b>parser_units</b> - implementation of the built-in units package,
interface to various measurement conversion routines.</li>
</ul>

<p><br>Main Program
<ul>
<li>
<b>bush</b> - shows --help instrutions, interprets command line option
switches, invokes the BUSH parser</li>
</ul>

<h3>
<a NAME="5.2"></a><font color="#666600">5.2 Porting BUSH to UNIX</font></h3>
You will need a basic knowledge of Ada (how to declare a procedure, how to
declare variables, etc.).&nbsp; For example, read chapter
10 of the Big Online Book of Linux Ada Programming (http://www.pegasoft.ca/resources/boblap/book.html).
<p>Install  GCC with the Ada language enabled.&nbsp; Either use GCC
3.x or later with the Ada language active or downloaded a version of GNAT
for your computer from New York University (ftp://cs.nyu.edu/pub/gnat).&nbsp;
The NYU site has Solaris An SCO UNIX version is available at
http://www.gnuada.org/sco.html.&nbsp;
A NetBSD version is available at http://www.gnuada.org/netbsd.html.&nbsp;
Older versions for other operating systems are lurking around on the web,
but GCC 3.x might be your best solution.
<p>The bush_os packages (bush_linux, etc.) contain binding to UNIX/Linux
system calls and other operating system constants.&nbsp; To port BUSH to
a UNIX-based operating system, make a copy of bush_linux and rename it
to your operating system.&nbsp; Then edit the file and make sure all the
system calls and constants are updated to reflect your version of UNIX.&nbsp;
This is (theoretically) the only BUSH package that needs to be modified.
<p>You will have to check the man pages and the C include files to find
the necessary information.&nbsp; For example, to get tty driver ioctl()
values (TCGETATTR, etc.) you may have to read the C include files looking
for TCGETATTR (or the equivalent).
<p>It may be possible that your version of UNIX doesn't have a particular
system call.&nbsp; You may have to fake the call using other operating
system calls.&nbsp; For example, "htons" is a macro on HP-UX, not a function
call.&nbsp; Since htons does nothing on HP-UX, write a htons function for
the bush_hp package that returns unchanged whatever parameter it is given.
<p>Run the BUSH test suite and try the command line features to make sure
your bush_os bindings are correct.
<p>If you have a working version of BUSH, you should now update the configure
scripts and GNUmakefile's to recognize your operating system.  The configure
script is a shell script that verifies all required libraries are installed,
identifies your operating system, installs the proper bush_os file for
your operating system, and then creates the Makefiles needed to compile BUSH.
Change update configure to recognize your operating system and install the
your new bush_os file.  This is normally all you need to do.</p>
<p>If you need to update the GNUmakefile's as well, change the ones named
GNUmakefile.orig: these are the originals that configure uses to produce the
final GNUmakefiles.
<p>Finally, send your changes to Ken and he will add it to the BUSH source
code.
<br>&nbsp;
<h3>
<a NAME="5.3"></a><font color="#666600">5.3 Porting BUSH to MS-DOS or Windows</font></h3>
BUSH was designed to run on UNIX/Linux operating systems.&nbsp; It was
not designed to run on Windows.&nbsp; It is, of course, possible to port
BUSH to Windows or MS-DOS, but it will take more work that porting it to
a UNIX variation.
<p>You will need to understand the Ada language since you'll probably have
to write functions which simulate UNIX system calls.&nbsp; For example,
read chapters 10 and 11 of the Big Online Book of Linux Ada Programming
(http://www.pegasoft.ca/homes/book.html).
<p>To port BUSH to MS-DOS, download the GNAT compiler for DOS available
at http://www.gnuada.org/dos.html.&nbsp; This compiler is based on DJGPP
which includes libraries that implement many UNIX functions on DOS.&nbsp;
Ken has not used DJGPP so he cannot tell you how many required UNIX functions
are missing.
<p>The bush_os packages (bush_linux, etc.) contain binding to UNIX/Linux
system calls and other operating system constants.&nbsp; To port BUSH to
a MS-DOS, make a copy of bush_linux and rename it to bush_dos.&nbsp;&nbsp;&nbsp;
You may have to fake some UNIX call using MS-DOS calls.
<p>You may also have to modify user_io which is UNIX-specific.&nbsp; (Someday
Ken intends to move the operating system specific parts of user_io into
bush_os, but he hasn't gotten around to it yet.&nbsp; If you're undertaking
a MS-DOS or Windows port, you may want to do this as well.)
<p>To port BUSH to Windows, you need to download GNAT for Windows from
New York University (ftp://cs.nyu.edu/put/gnat).&nbsp; This version of
GNAT is based on mingw (not Cygwin, the POSIX layer which sits on top of
the Win32 API to enable porting of UNIX software).&nbsp;GNAT for Windows
produces native applications which run directly on the Win32 API.&nbsp; Ken
has no knowledge of mingw so don't ask him any questions.&nbsp; If
mingw doesn't emulate any UNIX system calls, then most of bush_os will
have to be written with bindings to fake the UNIX calls using Windows calls.
<p>Ken has received a number of requests for a Windows port.&nbsp; Although
it will be a challenge, there is apparently a lot of interest in it and
your work will not be wasted.
<p>Run the BUSH test suite and try the command line features to make sure
your bush_os bindings are correct.
<p>Finally, send Ken your bush_os file and he will add it to the BUSH source
code.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="5.4"></a><font color="#666600">5.4 Adding New Built-in Packages</font></h3>
This is not a discussion on language design.&nbsp; This is a quick overview
on adding new built-in packages.&nbsp; We'll use the Ada.Calendar.Year
package as an example binding.
<p>In the current version of BUSH, packages are hard-coded into the parser.&nbsp;
There's no ability to create separate files that can be loaded on demand.&nbsp;
Some day this ability may be added.
<p>If you're adding a third-party Ada project (like AdaCGI), create a subdirectory
to hold the project and modify the main BUSH makefile to compile (and make
clean) the project.&nbsp; Test your changes by making a clean rebuild of
BUSH.
<p>Now you need to declare your identifiers.  Each package should have a Startup
and Shutdown procedure.  Edit <b>scanner.adb</b> and make sure your package Startup
and Shutdown procedures are called (look for the others in the file).
<p>Your package spec should declare all your the identifier variables.
For example, if you were implementing the Ada.Calendar package,
create a cal_clock_t, cal_year_t and so on for each identifier you'll need.&nbsp;
Include any types.&nbsp; By convention these end in "_t" (for "token").
<p><tt>-- Built-in Calendar package identifiers</tt><tt></tt>
<p><tt>cal_clock_t : identifier; -- "calendar.clock"</tt>
<p>Add declaration calls in your Startup procedure
to declare the identifier variables (that is, add them to the symbol table
and identify what types they are).&nbsp; Copy some of the other declarations
that are similar to the ones you are doing.&nbsp; For example, to declare
Ada.Calendar's time type,
<p><tt>declareIdent( cal_time_t, "calendar.time", variable_t, typeClass
);</tt>
<p>There are several declare calls.&nbsp; <b>declareIdent</b> is a general
purpose declaration that uses the identifier variable, the name of the
identifier (as the user would type it), what root type it's derived from
(variable_t is used for private types, integer_t for integers, string_t
for strings, and so forth), and the class of identifier (typeClass for
a type declaration, subClass for a subtype declaration, and so forth).
<p>Recompile BUSH and check for errors.
<p>The BUSH scanner now recognizes your identifiers.&nbsp; Move onto the
BUSH parser.
<p>Create an Ada package&nbsp; to contain your new BUSH built-in package.&nbsp;
You can copy one of the existing packages and edit it.&nbsp; Each package
consists of two files: a package specification and a package body.&nbsp;
For now, create a package specification.&nbsp; For example, for Ada.Calendar
you could create a file called "parser_cal.ads".
<p>The package specification should contain a series of "Parse" procedures.&nbsp;
These will be called by BUSH when it needs to run subprograms in the built-in
package.&nbsp; If a parse procedure defines a function, it should have
one out unbounded_string parameter (to return the result of the function).&nbsp;
Procedures, which return nothing, have no parameters.&nbsp; For the Ada.Calendar
package, you might have:
<p><tt>procedure ParseCalClock( result : out unbounded_string );&nbsp;
-- Ada.Calendar.Clock function</tt>
<br><tt>procedure ParseCalYear( result : out unbounded_string );&nbsp;
-- Ada.Calendar.Year function</tt>
<br><tt>procedure ParseCalMonth( result : out unbounded_string ); -- Ada.Calendar.Month
function</tt>
<br><tt>procedure ParseCalSplit; -- Ada.Calendar.Split procedure</tt>
<p>For each of these procedures, follow them with a <b>stub pragma</b>
<p><tt>procedure ParseCalClock( result : out unbounded_string ); -- Ada.Calendar.Clock
function</tt>
<br><tt>pragma import( stubbed, ParseCalClock );</tt>
<p>This GCC Ada pragma indicates that ParseCalClock has not been completed
and it will raise a PROGRAM_ERROR exception if the procedure is called.&nbsp;
When you complete the ParseCalClock procedure, remove the stub pragma.
<p>Compile the package specification with <b>gcc -c</b> to make sure there
are no obvious errors.
<p>Now tie your package specification into the parser.&nbsp; Edit the parser.adb
file and add the name of your package with the "with" and "use" statements
at the top of the file.
<p>Get BUSH to take action when it sees a procedure or function.&nbsp;
(This is the purpose of those identifier variables you declared earlier.)&nbsp;
BUSH checks for built-in package procedures in <b>ParseGeneralStatement</b>.&nbsp;
It checks for built-in package functions in <b>ParseFactor</b>.
<p>For an Ada.Calendar package, add the check for the Ada.Calendar.Split
procedure in ParseGeneralStatement:
<p><tt>elsif token = cal_split_t then -- are we looking at "calendar.split"?</tt>
<br><tt>&nbsp;&nbsp; ParseCalSplit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- then process a calendar.split call</tt>
<p>Add functions like Ada.Calendar.Clock to ParseFactor.&nbsp; The parameter
is always "f" (the value of the "factor" and the variable "kind" must be
set to the identifier variable for the type of result (e.g. an integer
result has a kind of integer_t).
<p><tt>elsif token = cal_clock_t then -- are we looking at "calendar.clock"?</tt>
<br><tt>&nbsp; ParseCalClock( f );</tt>
<br><tt>&nbsp; kind := cal_tile_t;</tt>
<p>Recompile BUSH to check for errors.&nbsp; Try using the procedures and
functions.&nbsp; Each should raise a PROGRAM_ERROR exception but should
have no other errors.
<p>The only thing left to do is to check the parameters to the subprograms
and execute them.&nbsp; Create a package body file and being implementing
the Parse procedures one at a time.&nbsp; As you implement each, remove
the corresponding stub pragma from the specification file.
<p>The variable "token" represents the current item in the source file.&nbsp;
To move to the next item in the source file, use the <b>expect </b>procedure.&nbsp;
Typically, you are only looking for an identifier or a punctuation mark.&nbsp;
For example,
<p><tt>&nbsp;&nbsp; expect( cal_clock_t ); -- expect the identifier "calendar.clock"</tt>
<br><tt>&nbsp;&nbsp; expect( symbol_t, "(" ); -- expect the punctuation
mark "("</tt>
<p>The parser has some Parsing functions that automatically process and
report errors.&nbsp; An important ones are:
<p><tt>&nbsp;&nbsp; ParseExpessions( val, kind ); -- interpret any kind
of expression.&nbsp; Return the value and the type.</tt>
<p><tt>&nbsp;&nbsp; ParseIdentifier( id ); -- interpret an identifier.
&nbsp; Return the id number for the identifier.</tt>
<p><tt>&nbsp;&nbsp; ParseOutParameter( id, kind ); -- interpret an identifier.
&nbsp; Return the id number of the identifier.  If it doesn't exist, it will be
declared as a kind variable (if auto-declarations are allowed by the user).</tt>
<p><tt>&nbsp;&nbsp; ParseInOutParameter( id, kind ); -- interpret an identifier.
&nbsp; Return the id number of the identifier.</tt>
<p>Using expect and ParseExpression you can read through the parameters
for most functions.&nbsp; For example, to Ada.Calendar.Year has one parameter:
<p><tt>&nbsp; year_value : unbounded_string;</tt>
<br><tt>&nbsp; year_type : identifier;</tt>
<br><tt>begin</tt>
<br><tt>&nbsp; expect( cal_year_t );</tt>
<br><tt>&nbsp; expect( symbol_t, "(" );</tt>
<br><tt>&nbsp; ParseExpression( year_value, year_type );</tt>
<br><tt>&nbsp; expect( symbol_t( ")" );</tt>
<p>Don't check for a semi-colon.&nbsp; BUSH will do that later.
<p>Now add the type checks.
<p>The scanner has several functions to check the type of an identifier.&nbsp;
The main procedure is <b>baseTypesOK</b>.&nbsp; This compares two type
identifiers and verifies they are compatible with one another.&nbsp; You
don't have to report the error: baseTypesOK will do this for you.&nbsp;
baseTypes also handles derrived types and subtypes.
<p><tt>expect( cal_year_t );</tt>
<br><tt>expect( symbol_t, "(" );</tt>
<br><tt>ParseExpression( year_value, year_type );</tt>
<br><tt>if baseTypesOK( year_type, cal_time_t ) then&nbsp; -- year should
be a calendar.time type or compatible</tt>
<br><tt>&nbsp;&nbsp; null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- do nothing special if type is OK</tt>
<br><tt>end if;</tt>
<br><tt>expect( symbol_t( ")" );</tt>
<p>Recompile BUSH again and check your work.&nbsp; Although calendar.year
does nothing yet, BUSH should understand the parameters.&nbsp; Using an
integer or a character parameter instead of a calendar.time parameter should
cause an error.&nbsp; Leaving out a "(" or ")" should also cause an error.&nbsp;
Check your definition of types using the env command
<p><tt>=> env calendar.time</tt>
<br><tt>calendar.time = ( private type )</tt>
<br><tt>=> env calendar.year</tt>
<br><tt>calendar.year = ( identifier of type keyword )</tt>
<p>BUSH has no formal representation for functions and procedures at this
time.&nbsp; They will be reported as keywords.
<p>Finally, you need to actually execute the subprogram.&nbsp; Before you
execute anything, check to see if you should execute the function with
the BUSH i<b>sExeuctingCommand</b> function.&nbsp; If BUSH is doing a syntax
check of a script, or if an error was previously encountered, isExecutingCommand
will be false.
<p>It is also a good idea to wrap the function or procedure you are calling
in an Ada declare block to catch and report any exceptions.&nbsp; Otherwise,
BUSH will crash because of the exception.
<p>All the parameters are unbounded strings and will have to be converted
to the appropriate Ada type needed for the parameters.&nbsp; In the case
of Ada.Calendar.Year,
<p><tt>if isExecutingCommand then</tt>
<br><tt>&nbsp;&nbsp; begin</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result := to_unbounded_string( year(
time( to_numeric( year_value ) ) )'img );</tt>
<br><tt>&nbsp;&nbsp; exception when others =></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err( "exception raised" );</tt>
<br><tt>&nbsp;&nbsp; end;</tt>
<br><tt>end if;</tt>
<p>An explaination of the conversions:
<ul>
<li>
to_numeric - convert the unbounded_string year_value to a numeric type
(in particular, a long_float)</li>

<li>
time() - convert the long float year_value to a calendar.time type</li>

<li>
year() - call the calendar.year function</li>

<li>
'img - convert the numeric result of calendar.year to a basic Ada fixed
string</li>

<li>
to_unbounded_string - convert the fixed string result to an unbounded_string
to be returned to ParseFactor</li>
</ul>
Rebuild BUSH and test the function to make sure it works.&nbsp; You've
completed the implementation of "calendar.year".&nbsp; Complete and test
the rest of the bindings.
<p>The actual ParseCalYear function is in the parser_cal.adb file.&nbsp;
The only difference to the calendar package compared to what you did here
was that Ada.Calendar.Time was a private type so BUSH implements its own
calendar package using a normal type so that time values can be converted
to strings.
<p>&nbsp;<a href="#top">Back to Top</a></p>
</body>
</html>
