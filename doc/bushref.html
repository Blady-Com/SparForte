<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Ken Burtch">
  <meta name="GENERATOR"
 content="Mozilla/4.78 [en] (X11; U; Linux 2.4.7-10 i686) [Netscape]">
  <title>Business Shell (BUSH) Guide</title>
</head>
<body bgcolor="#cccc99">
<center>
<img src="bush_title_bar.gif" alt="[BUSH User Guide]" height="99"
 width="710"></center>
<!-- h2>
<font color="#777700">Bush Guide: Part 3 - Language Reference</font></h2 -->

<table summary="menu" border="0" cellpadding="0" cellspacing="0"
 width="100%">
<tr>
<td valign="bottom" bgcolor="white">&nbsp;</td>
</tr><tr>
<td valign="bottom" bgcolor="white">
<table summary="menu" border="0" cellpadding="0" cellspacing="0"
 width="100%">
  <tbody>
    <tr bgcolor="white">
      <td align="center"><a href="http://www.pegasoft.ca/bush.html">Home Page</a></td>
      <td align="center"><a href="bushintro.html">Introduction</a></td>
      <td align="center"><a href="bushtutorial.html">Tutorials</a></td>
      <td valign="bottom" align="center" bgcolor="#CCCC99"><font size="+1" color="#777700"><b>Reference</b></font></td>
      <td align="center"><a href="bushpackages.html">Packages</a></td>
      <td align="center"><a href="bushdetails.html">Hacking</a></td>
    </tr>
  </tbody>
</table>
</td>
</tr>
</table>

<ul>
  <li><a href="#3.1">3.1 AdaScript versus GCC</a></li>
  <li><a href="#3.2">3.2 Case Sensitivity</a></li>
  <li><a href="#3.3">3.3 Reserved Words</a></li>
  <li><a href="#3.4">3.4 Comments</a></li>
  <li><a href="#3.5">3.5 Literals</a></li>
  <li><a href="#3.6">3.6 Bourne Shell Arguments</a></li>
  <li><a href="#3.7">3.7 Fundamental Types</a></li>
  <li><a href="#3.8">3.8 User-defined Types</a></li>
  <li><a href="#3.9">3.9 Enumerated Types</a></li>
  <li><a href="#3.10">3.10 Arrays</a></li>
  <li><a href="#3.11">3.11 Records</a></li>
  <li><a href="#3.12">3.12 Basic Assignment</a></li>
  <li><a href="#3.13">3.13 The @ and %</a></li>
  <li><a href="#3.14">3.14 Command Argument Shortcuts</a></li>
  <li><a href="#3.15">3.15 Redirection and Pipelines</a></li>
  <li><a href="#3.16">3.16 Command Line Interaction</a></li>
  <li><a href="#3.17">3.17 Interactive Statements</a></li>
  <li><a href="#3.18">3.18 The Current Directory</a></li>
  <li><a href="#3.19">3.19 Database Commands</a></li>
  <li><a href="#3.20">3.20 Flow of Control</a></li>
  <li><a href="#3.21">3.21 Other Statements/Subprograms</a></li>
  <li><a href="#3.22">3.22 External Commands</a></li>
  <li><a href="#3.23">3.23 Block Statements and Subprograms</a></li>
  <li><a href="#3.24">3.24 TCP/IP Sockets</a></li>
  <li><a href="#3.25">3.25 Numeric Formatting with Put</a></li>
  <li><a href="#3.26">3.26 Interpreter Directives</a></li>
  <li><a href="#3.27">3.27 Command Line Options</a></li>
  <li><a href="#3.28">3.28 Command Reference</a></li>
  <li><a href="#3.29">3.29 ASCII and Latin_1 Character Sets</a></li>
  <li><a href="#3.30">3.30 Common Error Messages</a></li>
  <li><a href="#3.31">3.31 Common PHP Functions and the BUSH Equivalent</a></li>
</ul>
<hr></tt></a>This part of the guide provides a technical overview of
the
AdaScript language including the basic types, keywords, syntax structures
and Bourne shell commands.
<h3><a name="3.1"></a><font color="#777700">3.1 AdaScript versus GCC
Ada 95</font></h3>
The computer language that the BUSH shell understands is called
<b>AdaScript</b>.
Unlike JavaScript, which has no relation to Java, AdaScript is a small
subset of the Ada programming language, with additional features
related
to shell commands.
<p>AdaScript is intended to be "upward compatible" with Ada.&nbsp;
AdaScript
scripts should run with little difficulty under Ada, but Ada programs
may
require large changes run under BUSH.
<br>
&nbsp;
</p>
<h3><a name="3.2"></a><font color="#666600">3.2 Case Sensitivity</font></h3>
AdaScript is a case-sensitive language because shell variables and
Linux
commands are all case-sensitive.&nbsp; If AdaScript ignored the case of
variables and commands, some commands couldn't be run and some
variables
couldn't be used.
<br>
&nbsp;
<br>
&nbsp;
<p>Ada is case-insensitive and programs may need to have the
capitalization
of keywords changed to fit the case expected by AdaScript.
<br>
&nbsp;
</p>
<h3><a name="3.3"></a><font color="#666600">3.3 Reserved Words</font></h3>
AdaScript has a number of reserved words. These are keywords that have a
special significance to the language and they cannot be used as
variable
names.&nbsp; The following table lists all reserved words.&nbsp; They
are
only reserved when in lower case.
<br>
&nbsp;
<table nosave="" bgcolor="#ffff99" border="1" cols="4" width="100%">
  <tbody>
    <tr nosave="" valign="top">
      <td nosave=""><tt>abort</tt> <br>
      <tt>abs</tt> <br>
      <tt>abstract</tt> <br>
      <tt>accept</tt> <br>
      <tt>aliased</tt> <br>
      <tt>all</tt> <br>
      <tt>and</tt> <br>
      <tt>array</tt> <br>
      <tt>at</tt> <br>
      <tt>begin</tt> <br>
      <tt>body</tt> <br>
      <tt>case</tt> <br>
      <tt>clear</tt> <br>
      <tt>constant</tt> <br>
      <tt>declare</tt> <br>
      <tt>delay</tt> <br>
      <tt>delta</tt> <br>
      <tt>digits</tt> <br>
      <tt>do</tt><br>
      <tt>else</tt></td>
      <td><tt>elsif</tt> <br>
      <tt>end</tt> <br>
      <tt>entry</tt> <br>
      <tt>env</tt> <br>
      <tt>exception</tt> <br>
      <tt>exit</tt> <br>
      <tt>for</tt> <br>
      <tt>function</tt> <br>
      <tt>generic</tt> <br>
      <tt>goto</tt> <br>
      <tt>help</tt> <br>
      <tt>if</tt> <br>
      <tt>in</tt> <br>
      <tt>interface</tt> <br>
      <tt>is</tt> <br>
      <tt>jobs</tt> <br>
      <tt>limited</tt> <br>
      <tt>logout</tt> <br>
      <tt>loop</tt></td>
      <td><tt>mod</tt> <br>
      <tt>new</tt> <br>
      <tt>not</tt> <br>
      <tt>null</tt> <br>
      <tt>of</tt> <br>
      <tt>or</tt> <br>
      <tt>others</tt> <br>
      <tt>out</tt> <br>
      <tt>package</tt> <br>
      <tt>pragma</tt> <br>
      <tt>private</tt> <br>
      <tt>procedure</tt> <br>
      <tt>protected</tt> <br>
      <tt>raise</tt> <br>
      <tt>range</tt> <br>
      <tt>record</tt> <br>
      <tt>rem</tt> <br>
      <tt>renames</tt> <br>
      <tt>requeue</tt></td>
      <td>r<tt>eturn</tt> <br>
      <tt>reverse</tt> <br>
      <tt>select</tt> <br>
      <tt>separate</tt> <br>
      <tt>subtype</tt> <br>
      <tt>tagged</tt> <br>
      <tt>task</tt> <br>
      <tt>terminate</tt> <br>
      <tt>then</tt> <br>
      <tt>trace</tt> <br>
      <tt>type</tt> <br>
      <tt>typeset</tt> <br>
      <tt>unset</tt> <br>
      <tt>until</tt> <br>
      <tt>use</tt> <br>
      <tt>when</tt> <br>
      <tt>while</tt> <br>
      <tt>with</tt> <br>
      <tt>xor</tt></td>
    </tr>
  </tbody>
</table>
<p>If you attempt to use a reserved word, you will receive a error
</p>
<p><tt>=&gt; digits : integer</tt>
<br>
<tt>digits : integer;</tt>
<br>
<tt>^ identifier expected, not a keyword</tt>
<br>
<tt>=&gt; DIGITS : integer</tt>
<br>
<tt>=&gt;</tt>
</p>
<p>All Ada keywords are also reserved, even those that are not used by
AdaScript, to make it easier to compile scripts under GCC Ada.
<br>
&nbsp;
</p>
<h3><a name="3.4"></a><font color="#666600">3.4 Comments</font></h3>
Comments are denoted by a "--" and all text after these
symbols is ignored until the end of line.<br>
<br>
<tt>=&gt; null; -- An Ada style comment</tt>
<br>
&nbsp;
<br>
As a special case, scripts may begin with a path to the interpreter as
specified with "#!".&nbsp; BUSH doesn't honor any parameters included
with the path.<br>
<br>
<span style="font-family: monospace;">#!/usr/local/bin/bush</span><br>
<br>
In this case, the operating system would look for BUSH in
/usr/local/bin if the script file is executed directly.&nbsp; This is
the standard behavior for Linux and UNIX-based operating systems.<br>
<br>
<h3><a name="3.5"></a><font color="#666600">3.5 Literals</font></h3>
<font color="#000000">Numbers (numeric literals) can contain a decimal
point.&nbsp; An alternate base (hex, octal, etc.) can be specified by
following
the base with the value between '#'.&nbsp; Hexadecimal letter
characters
can be in upper or lower case.&nbsp; Scientific notation is not yet
supported.</font>
<pre>=&gt; ? 16#FFFF#<br> 65535<br></pre>
&nbsp;
&nbsp;<br>
<ul>
  <li> <font color="#000000"><tt>5</tt> - the integer 5</font></li>
  <li> <font color="#000000"><tt>5.0</tt> the integer 5.0</font></li>
  <li> <font color="#000000"><tt>8#777#</tt> - the octal value 511</font></li>
  <li> <font color="#000000"><tt>16#ff#</tt> - the hexadecimal value
255</font></li>
</ul>
<p><br>
<font color="#000000">Characters are enclosed in single quotes.</font>
<br>
&nbsp;
</p>
<ul>
  <li> <font color="#000000"><tt>'a'</tt> - the character a</font></li>
</ul>
<p><br>
<font color="#000000">Strings are enclosed in double quotes.</font>
<br>
&nbsp;
</p>
<ul>
  <li> <font color="#000000"><tt>"hello" </tt>- the string hello</font></li>
</ul>
<br>
<h3><a name="3.6"></a><font color="#777700">3.6 Bourne Shell Arguments<br>
</font></h3>
BUSH provides a subset of Bourne shell features for convenient use on
the command line.&nbsp; Many new users are already familiar with the
Bourne
shell since it's the standard shell for Linux and FreeBSD.&nbsp; Also,
the AdaScript syntax can be awkward to use for simple interactive
commands.&nbsp; Where the Bourne standard conflicts with Ada BUSH
always favors compatibility with Ada for the sake of the progressive
development model.<br>
<br>
Bourne shell arguments consist of groups of characters called
"words".&nbsp; Each word is separated by spaces.&nbsp; BUSH does not
implement the Bourne shell IFS variable.<br>
<br>
Argument expansion is the process of performing substitutions on a
Bourne shell word.&nbsp; Argument expansion occurs at run-time since it
depends on the current working directory and the current value of
variables.<br>
<br>
Bourne shell expansions include:<br>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Brace Expansion<br>
      </td>
      <td style="vertical-align: top;">a.{txt,.dat}<br>
      </td>
      <td style="vertical-align: top;">a.txt a.dat<br>
      </td>
      <td style="vertical-align: top;">not implemented<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Tilde Expansion<br>
      </td>
      <td style="vertical-align: top;">~a/a.txt<br>
      </td>
      <td style="vertical-align: top;">/home/user/a.txt<br>
      </td>
      <td style="vertical-align: top;">OK<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Variable Expansion<br>
      </td>
      <td style="vertical-align: top;">$HOME/a.txt<br>
      </td>
      <td style="vertical-align: top;">/home/usr/a.txt<br>
      </td>
      <td style="vertical-align: top;">OK<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Command Substitution<br>
      </td>
      <td style="vertical-align: top;">`/bin/echo a.txt`<br>
      </td>
      <td style="vertical-align: top;">a.txt<br>
      </td>
      <td style="vertical-align: top;">Backquotes only<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Arithmetic Expansion<br>
      </td>
      <td style="vertical-align: top;">$((2+2))<br>
      </td>
      <td style="vertical-align: top;">4<br>
      </td>
      <td style="vertical-align: top;">not implemented<br>
(use AdaScript parameters)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Pathname Expansion<br>
      </td>
      <td style="vertical-align: top;">a.*<br>
      </td>
      <td style="vertical-align: top;">a.txt a.dat<br>
      </td>
      <td style="vertical-align: top;">OK<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Word Splitting<br>
      </td>
      <td style="vertical-align: top;">a\ word<br>
      </td>
      <td style="vertical-align: top;">"a word"<br>
      </td>
      <td style="vertical-align: top;">OK<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
There is no brace expansion, arithmetic expansion or process
substitution.&nbsp; Some features support only a subset of the BASH
features.&nbsp; For example, many of the special $ substitutions
(${...}, $(...) and others) are not implemented.&nbsp; Otherwise, the
basic Bourne shell features implemented in BUSH conform to
the POSIX standard.<br>
<br>
<br>
<h3>
<a name="3.7"></a><font color="#777700">3.7 Fundamental Types</font></h3>
All AdaScript variables have a type.&nbsp; Variables must declared so
that
BUSH knows what that type is.&nbsp; When new variables are created by
assignment
at the command prompt, BUSH choses an appropriate type for the new
variable.&nbsp;
In scripts, all variables must be declared.
<br>
&nbsp;
<p><i>Universal Types</i>
</p>
<p>There are three "universal types":
<br>
&nbsp;
<table nosave="" bgcolor="#ffff99" border="1" cols="3" width="100%">
  <tbody>
    <tr>
      <td><b>Type Name</b></td>
      <td><b>Content</b></td>
      <td><b>Usage</b></td>
    </tr>
    <tr>
      <td><tt>universal_string</tt></td>
      <td>unlimited length, 8-bit characters</td>
      <td>text</td>
    </tr>
    <tr>
      <td><tt>universal_numeric</tt></td>
      <td>double precision floating point values</td>
      <td>numbers</td>
    </tr>
    <tr>
      <td><tt>universal_typeless</tt></td>
      <td>same as universal_string/numeric</td>
      <td>text or numbers</td>
    </tr>
  </tbody>
</table>
</p>
<p>The first two types form the basis for all other AdaScript string
and
numeric types.&nbsp; Variables declared as universal_typeless change
their
type between universal_string and universal_numeric depending how they
are used.&nbsp; If AdaScript cannot decide in a particular context, the
variable type defaults to universal_string.&nbsp; Typeless variables
correspond
to variables in Bourne shells and are provided for as a command line
convenience.
</p>
<p>Universal types automatically match any type derived from the same
universal
type. A universal_numeric variable accepts integer or floating point
values.&nbsp;
A universal_string variable accepts single characters or strings
containing
many characters.
</p>
<p>Universal types are used for all AdaScript literals.&nbsp; For
example,
a string literal like "hello" is a universal_string and be assigned to
any string type. The numeric literal 45.5 is a universal_numeric can be
used with float, long_float, or any other numeric type.
</p>
<p>Using these three built-in types will give you a minimum amount of
type
checking, suitable for short scripts or quick command line
calculations.&nbsp;
Universal types should not be used in large scripts because they will
greatly
reduce the number of errors BUSH can detect.
</p>
<p><i>Predefined, Non-Universal Types</i>
</p>
<p>For more extensive scripts, AdaScript extends the universal string
and
numeric types into all the predefined Ada language types, plus some
AdaScript-specific
types:
<br>
&nbsp;
<table nosave="" bgcolor="#ffff99" border="1" cols="4" width="100%">
  <tbody>
    <tr>
      <td><b>Type Name</b></td>
      <td><b>Base Type</b></td>
      <td><b>Usage</b></td>
      <td><b>GCC Ada Equivalent</b></td>
    </tr>
    <tr nosave="">
      <td nosave=""><tt>integer</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>number without a radix point</td>
      <td><tt>integer</tt></td>
    </tr>
    <tr>
      <td><tt>natural</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>0 or integer larger than zero</td>
      <td><tt>natural</tt></td>
    </tr>
    <tr>
      <td><tt>positive</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>integer larger than zero</td>
      <td><tt>positive</tt></td>
    </tr>
    <tr>
      <td><tt>short_short_integer</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>very small integer</td>
      <td><tt>short_short_integer</tt></td>
    </tr>
    <tr>
      <td><tt>short_integer</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>small integer</td>
      <td><tt>long_integer</tt></td>
    </tr>
    <tr>
      <td><tt>long_integer</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>large integer</td>
      <td><tt>long_long_integer</tt></td>
    </tr>
    <tr>
      <td><tt>long_long_integer</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>very large integer</td>
      <td><tt>float</tt></td>
    </tr>
    <tr>
      <td><tt>float</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>floating point number</td>
      <td><tt>float</tt></td>
    </tr>
    <tr>
      <td><tt>short_float</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>small floating point number</td>
      <td><tt>short_float</tt></td>
    </tr>
    <tr>
      <td><tt>long_float</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>large floating point number</td>
      <td><tt>long_float</tt></td>
    </tr>
    <tr>
      <td><tt>character</tt></td>
      <td><tt>universal_string</tt></td>
      <td>8-bit character</td>
      <td><tt>character</tt></td>
    </tr>
    <tr>
      <td><tt>string</tt></td>
      <td><tt>universal_string</tt></td>
      <td>unlimited length string</td>
      <td>almost <tt>unbounded_string</tt></td>
    </tr>
    <tr>
      <td><tt>unbounded_string</tt></td>
      <td>universal_string</td>
      <td>unlimited length string</td>
      <td>almost <tt>unbounded_string</tt></td>
    </tr>
    <tr>
      <td><tt>duration</tt></td>
      <td><tt>universal_numeric</tt></td>
      <td>time, float seconds</td>
      <td><tt>duration</tt></td>
    </tr>
    <tr>
      <td><tt>boolean</tt></td>
      <td>enumerated type</td>
      <td><tt>true</tt> or <tt>false</tt></td>
      <td><tt>boolean</tt></td>
    </tr>
    <tr>
      <td><tt>file_type</tt></td>
      <td>limited type</td>
      <td>operating system files</td>
      <td><tt>file_type</tt></td>
    </tr>
    <tr>
      <td><tt>file_mode</tt></td>
      <td>enumerated type</td>
      <td><tt>in_file</tt>, <tt>out_file</tt> or <tt>append_file</tt></td>
      <td><tt>file_mode</tt></td>
    </tr>
    <tr>
      <td><tt>command</tt></td>
      <td>limited type</td>
      <td>alias for an operating system command</td>
      <td>&nbsp;-</td>
    </tr>
  </tbody>
</table>
</p>
<p>The built-in packages may define additional types.
</p>
<p>By default, all numeric variables are initialized without any value.
Any attempt to use uninitialized numeric variables in an expression
will
cause an error or exception.
</p>
<p><tt>=&gt; i : integer -- no value specified</tt>
<br>
<tt>=&gt; i := i + 1</tt>
<br>
<tt>i := i + 1;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ exception
raised</tt>
</p>
<p>All types are <i>logical</i> types: that is, all numeric types are
stored
in the same format.&nbsp; A natural, integer or float are all stored as
a universal numeric value.&nbsp; There are only minimal checks to make
sure that variables of these types conform to their descriptions.
However,
types provide an indication to the reader of how a variable is intended
to be used, and AdaScript will not allow these types to be combined
without
an appropriate type cast.
</p>
<p><tt>=&gt; i : integer := 5</tt>
<br>
<tt>=&gt; f : float := 0</tt>
<br>
<tt>=&gt; f := i</tt>
<br>
<tt>f := i;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ type 'float' is not compatible
with type 'integer'</tt>
<br>
<tt>=&gt; f := float(i) -- typecast</tt>
<br>
<tt>=&gt; ? f</tt>
<br>
<tt>5</tt>
</p>
<p>You cannot typecast a numeric type into a string type
directly.&nbsp;
There are functions in the <a href="#numerics">numerics</a> and <a
 href="#strings">strings</a>
packages to do these conversions.
</p>
<p>Since all values are stored as a universal type, this can cause some
unusual side-effects. A character variable can contain more than one
character
if you really want it to by assigning a string literal. Characters are
stored as a universal_string and a string literal is a universal_string
type.&nbsp; AdaScript will allow the assignment.&nbsp; However, the
type
checking will prevent a character variable from being assigned to a
string
variable.
</p>
<p><tt>c : character;</tt>
<br>
<tt>c := "hello"; -- confusing, perhaps stupid, but legal</tt>
<br>
<tt>s : string := c; -- ILLEGAL</tt>
</p>
<p>AdaScript strings are an unbounded string type--that is, they are
stored
as an Ada.Strings.Unbounded.Unbounded_String variable.&nbsp; They have
an unlimited length and are not implemented as any sort of array.
Ada "fixed" strings, the default string type for GCC Ada, are not used
because they have limited length and can create array bounds exceptions.
Strings are an integral part of scripts and unbounded strings are used
instead.  AdaScript includes an unbounded_string type (it has the same
properties as the string type) which may make porting to GCC Ada easier.
</p>
<p><i>Constants</i>
</p>
<p>Constants can be declared with the word "constant" for any type. The
use of "constant" doesn't not affect the type of the variable--it
simply
prevents new values from being assigned by making the variable
"read-only".
</p>
<p><tt>program_name : constant string := "Nightly FTP Transfer";</tt>
</p>
<p><i>Limited Types</i>
</p>
<p>file_type and socket_type variables are known as <i>limited</i>
type
variables. Limited types cannot be assigned a new value with an
assignment
statement
</p>
<p><tt>=&gt; f : file_type</tt>
<br>
<tt>=&gt; g : file_type</tt>
<br>
<tt>=&gt; f := g</tt>
<br>
<tt>f := g;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ limited variables cannot be
assigned
a value</tt>
</p>
<p>BUSH manages the contents of these variables and scripts are not
allowed
to change the contents.<br>
</p>
<p><span style="font-style: italic;">Complex Types</span><br>
</p>
<p>Variables declared complex represent complex numbers.&nbsp; A
complex number is a record with long_float real and imaginary
parts.&nbsp; The real field is designated "re" and the imaginary field
is designated "im".&nbsp; (See below for more information about using
records.)<br>
</p>
<span style="font-family: monospace;">=&gt; c : complex := (
1.0, 2.0
)</span><br style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; ? c.re</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;1.0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; ? c.im</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;2.0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; c.re := 5.0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; ? c.re</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;5.0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; numerics.set_re( c, 3.0 )</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; ? c.re</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;3.0</span><br
 style="font-family: monospace;">
<br>
Some of the numerics package subprograms work with complex types.<br>
<p>Complex types are not fully implemented in this version of BUSH:
some of the Ada complex number functions are not available.<br>
<br>
</p>
<p><i>Command Types</i>
</p>
<p>External operating system commands can be declared using <b>command</b>
variables. When a command is declared, BUSH will ensure that the
command
exists and is runnable.
</p>
<p>Command types are similar to limited types and have several
restrictions.
</p>
<ul>
  <li>they must be declared as constants</li>
  <li>they cannot be assigned to other variables</li>
  <li>they cannot be used in expressions (although they can appear by
themselves
and are treated as strings)</li>
</ul>
<p><br>
<tt>=&gt; l : constant command := "/bin/ls"</tt>
<br>
<tt>=&gt; m : constant command := "/bin/lt"</tt>
<br>
<tt>m : constant command := "/bin/lt";</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^ "/bin/lt" is not an executable command</tt>
<br>
<tt>=&gt; n : constant command := l;</tt>
<br>
<tt>n : constant command := l;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^ type universal_string is inherently different from a command</tt>
<br>
<tt>=&gt; ? l &amp; " is the path"</tt>
<br>
<tt>? l &amp; " is the path";</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^ type command is inherently different from a universal_string</tt>
<br>
<tt>=&gt; ? l</tt>
<br>
<tt>/bin/ls</tt>
</p>
<h3><a name="3.8"></a><font color="#777700">3.8 User-defined Types</font></h3>
You can extend the fundamental types to create your own types.
<p>The <b>subtype</b> statement will create a type that is compatible
with
the original, as if it was a renaming of the original type.
</p>
<p><tt>=&gt; subtype int is integer;</tt>
<br>
<tt>=&gt; i1 : integer := 1</tt>
<br>
<tt>=&gt; i2 : int := 2</tt>
<br>
<tt>=&gt; ? i1 + i2</tt>
<br>
<tt>3</tt>
</p>
<p>In this case, "int" is equivalent to "integer" and variables of both
types can be mixed freely without type casting.&nbsp; Unlike Ada 95,
there
is no way to place restrictions on a subtype--they are simple renamings
in AdaScript.
</p>
<p>To make incompatible types, you need to create a new type with the <b>type</b>
statement.
</p>
<p><tt>=&gt; type employee_number is new integer;</tt>
<br>
<tt>=&gt; type customer_number is new integer;</tt>
<br>
<tt>=&gt; en : employee_number</tt>
<br>
<tt>=&gt; cn : customer_number</tt>
<br>
<tt>=&gt; en := cn</tt>
<br>
<tt>en := cn;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ type 'employee_number'
is not compatible with type 'customer_number'</tt>
</p>
<p>In this case, "employee_number" variables cannot be mixed with
"customer_number"
(or other) variables without a typecast. Use new types to make sure
variables
that are logically different don't accidentally mix.
</p>
<h3><a name="3.9"></a><font color="#777700">3.9 Enumerated Types</font></h3>
AdaScript also has an <b>enumerated type.</b> Enumerated types are
naturally
incompatible with one another, and the items in the enumerated list
cannot
be overloaded with other enumerated types.
<p><tt>=&gt; type fruit is (apple, blueberry, cherry);</tt>
<br>
<tt>=&gt; f : fruit</tt>
<br>
<tt>=&gt; f := apple</tt>
<br>
<tt>=&gt; f := 5</tt>
<br>
<tt>f := 5;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ type fruit (an enumerated type)
is inherently different from a universal_numeric</tt>
<br>
&nbsp;
</p>
<p>There are two built-in enumerated types.&nbsp; The <b>boolean</b>
type
is a predefined enumerated type with values "false" and "true".&nbsp;
The
<b>file_mode</b>
type has the values "in_file", "out_file" and "append_file".
</p>
<p>AdaScript has no aggregate types except for simple arrays and
records.
If you need these, your project is probably too complicated for a
simple script and should be upgraded to Ada 95.
<br>
&nbsp;
</p>
<h3><a name="3.10"></a><font color="#666600">3.10 Arrays</font></h3>
Arrays are lists of values of one type.&nbsp; Each value is accessed by
an
numeric or enumerated index.
<p>To declare an anonymous array (an array with no type name):
</p>
<p><tt>=&gt; zerbra_population : array(1900..1999) of natural</tt>
<br>
<tt>=&gt; type divisions is (america, asia, africa, eurpoe, oceania )</tt>
<br>
<tt>=&gt; sales : array (america..oceania) of float</tt>
</p>
<p>The first array contains 100 entries and each entry is a natural
number.&nbsp;
To assign values or to access array entries, put the index number in
parentheses
after the array name.
</p>
<p><tt>=&gt; zebra_population(1950) := 150000</tt>
<br>
<tt>=&gt; ? zebra_population( 1950 )</tt>
<br>
<tt>150000</tt>
</p>
<p>Attempting to use an out-of-range index number is an error
</p>
<p><tt>=&gt; ? zebra_population( 0 )</tt>
<br>
<tt>&nbsp;&nbsp; ^ exception raised</tt>
</p>
<p>You can create new array types.
</p>
<p><tt>=&gt; type zebra_list is array( 1900..1999 ) of natural;</tt>
<br>
<tt>=&gt; zl : zebra_list</tt>
</p>
<p>When you declare an array, you can assign a list of initial values
or
copy the values of another identical array.
</p>
<p><tt>=&gt; type grocery_list is array(1..10) of string</tt>
<br>
<tt>=&gt; gl : grocery_list := ( "milk", "bananas", "bread", "butter",
"salt", "flour", "pizza", "noodles",&nbsp; "", "" )</tt>
<br>
<tt>=&gt; gl2 : grocery_list := gl</tt>
<br>
<tt>=&gt; ? gl2(2)</tt>
<br>
<tt>bananas</tt>
</p>
<p>An empty array can be created using 1..0.&nbsp; This is the only
case
where the low bound is higher than the high bound.
</p>
<p><tt>=&gt; empty : array(1..0) of integer</tt>
</p>
<p>Bush does not support assigning one array to another in an
assignment
statement, unconstrained arrays or multi-dimensional arrays.
<br>
&nbsp;
</p>
<h3><a name="3.11"></a><font color="#666600">3.11 Records</font></h3>
Records (or "structs" in the C language) are a group of variables
collected
under a single name. Records can serve as tables or help to declare and
manage related information. Unlike arrays, records contain values of
different types.
<p>BUSH has limited support for record types and record variables.
</p>
<p>Before you declare a record, create a record type describing the
group
of variables a record will represent.
</p>
<p><tt><b>type</b> customer <b>is</b> <b>record</b></tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp; name : string;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp; address : string;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp; balance : float;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp; active : boolean;</tt>
<br>
<tt><b>end</b> <b>record</b>;</tt>
</p>
<p>This type describes a record containing five variables (or
"fields").
</p>
<p>To create a record variable, use this type.
</p>
<p><tt>sushi_express : customer;</tt>
</p>
<p>You can assign initial values when you declare the variable.
</p>
<p><tt>united_snorkels : customer := ("United Snorkels", "555 Snorkel
Street", 9456.45, true );</tt>
<br>
<tt>current_customer : customer := united_snorkels;</tt>
</p>
<p>To reference the parts of the record, use dot notation.
</p>
<p><tt>sushi_express.name := "Sushi Express Inc.";</tt>
<br>
<tt>put_line( sushi_express.name );</tt>
</p>
<p>BUSH supports only a small subset of GCC Ada's record features.
Arrays of
records, or records with arrays, and default values are not (yet)
supported.
Assigning records to records is only supported in declarations.
<br>
&nbsp;
</p>
<h3><a name="3.12"></a><font color="#777700">3.12 Basic Assignment
and Expressions</font></h3>
AdaScript expressions can contain the following operators:
<ul>
  <li> <b>uniary</b>: +, -, not</li>
  <li> <b>exponentiation</b>: **</li>
  <li> <b>arithmetic</b>: +, -, *, /, &amp; (string concatenation),
rem
(remainder),
mod (modulus), and (bitwise and), or (bitwise or), xor (bitwise xor), *
(string duplication)</li>
  <li> <b>relational</b>: =, /= (not equals), &gt;=, &gt;, &lt;=,
&lt;,
in, not in</li>
  <li> <b>boolean</b>: and, or, xor</li>
</ul>
The bitwise operators are identical to the boolean operators: BUSH
choses
which to use on the context of the expression.
<p>Assignment (:=) is a statement, not an operator, and cannot be used
in expressions.
</p>
<p><tt>=&gt; x := 5 * ( 7 + 2 );</tt>
<br>
<tt>=&gt; s := "hello " &amp; "there!";</tt>
</p>
<p>"in" and "not in" test for membership in a range. (In Ada, the range
can be a type but under AdaScript types have no bounds.) The range can
be an pair of numbers or a pair of enumerated items.
</p>
<p><tt>=&gt; b := green in red..blue;</tt>
<br>
<tt>=&gt; b := 5 not in 10..20;</tt>
<br>
&nbsp;
</p>
<h3><a name="3.13"></a><font color="#777700">3.13 The @ and %
Operands</font></h3>
AdaScript provides a self-referential operand. "@", pronounced
"itself",
returns the value of the variable on the left side of an assignment
statement.
Use @ to save yourself unnecessary typing.
<p><tt>=&gt; total := @ + 1; -- total := total + 1;</tt>
</p>
<p>(An operand is used instead of C-style "+=", "-=", and so forth
because
it's much more resilient to typos. Leaving out the "@" or transposing
it
with the ":=" or "+" will result in a syntax error. In C, these
mistakes
usually result in legal assignments.)
</p>
<p><tt>=&gt; result := 10 - @; -- impossible with C-style shortcuts</tt>
</p>
<p>When assigning a value to an array, @ refers to the array item being
assigned, not the entire array.
</p>
<p><tt>=&gt; zebra_population( 1966 ) := @+1; -- add 1 to 1966
population</tt>
</p>
<p>Common self-referential (or combined operator) shortcuts:</p>
<table cellspacing="0" cellpadding="0" border="1" summary="">
<tr>
<td><u>C style</u></td><td><u>Bush Style</u></td>
<td>temp++</td><td>temp:=@+1</td>
<td>++temp</td><td>temp:=@+1</td>
<td>temp--</td><td>temp:=@-1</td>
<td>--temp</td><td>temp:=@-1</td>
<td>temp+=x</td><td>temp:=@+x</td>
<td>temp-=x</td><td>temp:=@-x</td>
<td>temp*=x</td><td>temp:=@*x</td>
<td>temp/=x</td><td>temp:=@/x</td>
<td>temp%=x</td><td>temp:=@ mod x</td>
<td>temp.=x (PHP)</td><td>temp:= @&amp;x</td>
</tr>
</table>
<p>AdaScript provides a last output operand. "%", pronounced "last
output",
returns the last put_line (or ?) value. This is similar to Python's
last output
operand.
</p>
<p><tt>=&gt; put_line( 5*2 )</tt>
<br>
<tt>10</tt>
<br>
<tt>=&gt; put_line( %+5 )</tt>
<br>
<tt>15</tt>
</p>
<p>The type of the last output is remembered.
</p>
<p><tt>=&gt; put_line( 5 )</tt>
<br>
<tt>5</tt>
<br>
<tt>=&gt; put_line( % &amp; " is a good number" )</tt>
<br>
<tt>put_line( % &amp; " is a good number" );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
^ type universal_numeric is inherently different from a universal_string</tt>
</p>
<p>Use % for quick calculations at the command line.
<br>
&nbsp;
</p>
<h3><a name="3.14"></a><font color="#777700">3.14 Command Argument
Shortcuts</font></h3>
Parameters to the script are available using the built-in <a
 href="#cmdline">command_line</a>
package. However, for&nbsp; compatibility, the Bourne shell syntax can
also be used:
<ul>
  <li> <b><tt>$?</tt></b> - the status code for the last shell command
executed</li>
  <li> <b><tt>$0</tt></b> - the script name (not completely
implemented)</li>
  <li> <tt><b>$1</b> - <b>$9</b></tt> - up to 9 arguments given to
this
script</li>
  <li> <b><tt>$#</tt></b> - the number of arguments</li>
  <li> <b><tt>$$</tt></b> - the PID of this program, primarily used to
uniquely
name temporary files</li>
</ul>
If there are more than 9 arguments, they can be accessed with the
command_line
package.
<p>The Bourne shell form are intended as command line shortcuts and the
command_line package should normally be used in a well-structured
script.
</p>
<p><tt>rm ("/tmp/temp." &amp; $$)</tt>
<br>
<tt>if $? /= 0 then</tt>
<br>
<tt>&nbsp;&nbsp; put_line( standard_error, "unable to delete temp file"
);</tt>
<br>
<tt>end if;</tt>
</p>
<p>The status code of the last command executed is returned from a
script
when it finishes executing.&nbsp; A specific status code can be
returned
using the command_line package.
<br>
&nbsp;
</p>
<h3><a name="3.15"></a><font color="#666600">3.15 Redirection and
Pipelines</font></h3>
There are several operands that control input/output redirection.
<ul>
  <li> <tt><b>&gt;&nbsp; f</b> </tt>- redirect standard output to
file f,
creating
or overwriting f (not allowed in a restricted shell)</li>
  <li> <tt><b>&gt;&gt; f</b> </tt>- redirect standard output to file
f,
appending to
f</li>
  <li> <b><tt>&lt; f</tt> </b>- redirection input from file f</li>
  <li> <b><tt>2&gt; f</tt></b> - redirect error output to file f,
creating
or overwriting
f (not allowed in a restricted shell)</li>
  <li> <b><tt>2&gt;&gt; f</tt></b> - redirect error output to file f,
appending to f</li>
  <li> <b><tt>2&gt;&amp;1</tt></b> - redirect error output to standard
output (must appear
after a standard output redirection to redirect both to the same file)</li>
</ul>
The redirection operands should appear after the command.
<p><tt>=&gt; ls &gt; list_output.txt 2&gt; list_errors.txt</tt>
</p>
<p>The redirect operands are considered to be a command line
convenience.&nbsp;
More powerful redirection is possible using the Text_IO package.
</p>
<p>Command pipelines are created by connecting one or more commands
using
the pipe (|) symbol.
</p>
<p><tt>=&gt; ls | grep ".txt"</tt>
</p>
<p>The result from a command pipeline is the result of the last command
in the pipeline.&nbsp; Pipelines can only have one input redirection
(for
the first command), one output redirection and one error redirection
(for
the final command).&nbsp; Pipelines cannot be run in the background
using
&amp;.
<br>
&nbsp;
<br>
</p>
<h3><a name="3.16"></a><font color="#777700">3.16 Command Line Interaction</font></h3>
BUSH recognizes the Linux console arrow keys and common key sequences
for
the "emacs" and "vi" text editors. The sequences are called key
bindings
and represent cursor movement and editing functions.
<p>The <b>emacs mode</b> key bindings are:
</p>
<ul>
  <li> <b>control-b</b> - move back (left) one character</li>
  <li> <b>control-f</b> - move forward (right) one character</li>
  <li> <b>control-p</b> - move to the previous command line you typed</li>
  <li> <b>control-n</b> - move to the next command line you typed</li>
  <li> <b>control-x</b> - erase the command line</li>
  <li> <b>control-a</b> - move to start of the line</li>
  <li> <b>control-e</b> - move to end of the line</li>
  <li> <b>control-r</b> - search command lines (history) backwards</li>
  <li> <b>control-]</b> - character search forwards. (Follow with the
key
to search
for.)</li>
  <li> <b>tab</b> - complete the filename</li>
  <li> <b>backspace/delete</b> - delete a character</li>
</ul>
BUSH remembers up to 40 command lines for the current session, and you
can cycle through them using control-p and control-n.
<p>Typing a control-c (sending a SIGINT signal) at the command prompt
acts
the same as a control-x.&nbsp; Pressing control-c while a script or
command
is running will cause it to stop.
</p>
<p>If you prefer to use <b>vi cursor movement</b> instead, press the
escape
key to enter vi mode. Press escape again to return to emacs mode. In vi
mode, you can use lower-case 'h', 'j', 'k', 'l', '^' and '$'. Filename
completion is accomplished with two escape key presses in a row.
<br>
&nbsp;
</p>
<h3><a name="3.17"></a><font color="#777700">3.17 Interactive Statements</font></h3>
Interactive sessions refer to a user typing commands at the BUSH
command
prompt.&nbsp; AdaScript has a number of built-in statements to be used
in interactive sessions:

<p><b>help [-h|-m] [command or script]</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
<p>Display a summary of BUSH commands or show annotations (see pragma
annotate) in a script.  When showing annotations, -h will show the annotations
in HTML, -m as a Linux man page and, with no options, BUSH will show the
annotations as plain text.</p>
<p><u>Examples</u>:</p>
<pre>
<b>=&gt;</b> help reset
reset - reopen a file
  reset( file [,mode])
<b>=&gt;</b> help bjack.bush
Help for script bjack.bush:

Basic Blackjack

  A basic version of the Blackjack or 21 card game

Usage: bjack
</pre>
<u>Bash equivalent</u>: <tt>help</tt><br>
<u>Perl equivalent</u>: <tt>perldoc</tt><br>
<u>PHP  equivalent</u>: N/A<br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>env [ident [ident...]]</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
<p>Display a list of all declared identifiers, their values and their
properties, or the properties of a particular identifier.</p>
<p><u>Examples</u>:</p>
<pre>
=&gt; env ASCII.CR
ASCII.CR := '[# 13]'; -- constant character
=&gt; env | tail -5
PWD                  | /home/ken/ada/bush/example | imported identifier of the type string
                     | s                          |
HOME                 | /home/ken                  | imported identifier of the type string
OLDPWD               | /home/ken                  | identifier of the type universal_string
tail                 |                            | identifier of the type new
</pre>
<u>Bash equivalent</u>: <tt>env</tt><br>
<u>Perl equivalent</u>: <tt>Data::Dumper</tt><br>
<u>PHP  equivalent</u>: <tt>var_dump</tt><br>
</ul>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>trace [ boolean ]</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
<p>When trace is true, the lines being executed are displayed, along with
additional information in parentheses, showing how Bush interprets the commands.
The line number is displayed in square brackets after the line.  The first
line is not shown which means trace, at the Bush command prompt, always
displays "End of File" for line 2 because there is only one line to run.
trace by itself shows the current status (true or false).</p>
<p><u>Examples</u>:</p>
<pre>
<b>=&gt;</b> trace
Trace is currently off
<b>=&gt;</b> trace true
Trace is on
=&gt; "End of File" [ 2]
<b>=&gt;</b> ls | wc -l
=&gt; (shell word 'ls' expands to:)
=&gt; (ls)
=&gt; (exporting 'TERM=xterm')
=&gt; (/bin/ls output attached to input end of pipe fd 7)
=&gt; (shell word 'wc' expands to:)
=&gt; (wc)
=&gt; (shell word '-l' expands to:)
=&gt; (-l)
=&gt; (exporting 'TERM=xterm')
=&gt; (/usr/bin/wc input attached to output end of pipe fd 6)
68
=&gt; "End of File" [ 2]
</pre>
<u>Bash equivalent</u>: <tt>set -x</tt><br>
<u>Perl equivalent</u>: N/A<br>
<u>PHP  equivalent</u>: N/A<br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>unset ident</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
Permanently delete an identifier.  Keywords cannot be unset.  Unset can only
be used in an interactive session.  It cannot be used with pragma ada_95.
<p><u>Examples</u>:</p>
<pre>
<b>=&gt;</b> i : integer
<b>=&gt;</b> unset i
<b>=&gt;</b> ? i
? i;
  ^ <b>i</b> not declared</pre>
<u>Bash equivalent</u>: <tt>unset</tt><br>
<u>Perl equivalent</u>: N/A<br>
<u>PHP  equivalent</u>: <tt>unset</tt><br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>typeset var is type</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
Change the type of a variable, declaring it if necssary.  Typeset can only
be used in an interactive session.  It cannot be used with pragma ada_95.
<p><u>Examples</u>:</p>
<pre>
<b>=&gt;</b> typeset i is integer
<b>=&gt;</b> j : float
<b>=&gt;</b> typeset j is short_float
<b>=&gt;</b> env j
j := ; -- identifier of the type short_float</pre>
<u>Bash equivalent</u>: <tt>typeset</tt> or <tt>declare</tt><br>
<u>Perl equivalent</u>: N/A<br>
<u>PHP  equivalent</u>: N/A<br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>logout</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
Stop an interactive, login session and leave the BUSH shell.  BUSH uses a
login session if BUSH is your login shell or if you start BUSH with the
<tt>--login</tt> option.  When in the debugger (breakout mode), stop debugging
and leave the BUSH shell.  If the session is not a login session, an error is
displayed.  Normally, <tt>return</tt> will exit BUSH.  login is required for
login sessions to prevent the user from mistakenly logging themselves out if
quitting multiple shells, to let the user know they are in their top-most
shell.
<p><u>Examples</u>:</p>
<pre>
<b>=&gt;</b> return
return;
^----^ warning: This is a login shell.  Use <b>logout</b> to quit.
<b>=&gt;</b> logout
</pre>
<u>Bash equivalent</u>: <tt>logout</tt><br>
<u>Perl equivalent</u>: N/A<br>
<u>PHP  equivalent</u>: N/A<br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>clear</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
Reset the display device and clear the screen, placing the cursor in the
top-left corner of the display.
<u>Bash equivalent</u>: <tt>tput reset; stty sane; tput clear</tt><br>
<u>Perl equivalent</u>: N/A<br>
<u>PHP  equivalent</u>: N/A<br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<h4>Interactive Sessions versus Scripts</h4>

<p>Interactive sessions have the following limitations or features:</p>

<ul>
<li>The final semi-colon is optional.&nbsp; If it is missing, BUSH will
append a semi-colon before executing the command.&nbsp;
(If an error occurs, the entire line will be shown, including the extra
semi-colon.)&nbsp; Semi-colons will have to be placed after every command
except the final command.
<pre>
<b>=&gt;</b> ? "hello"
hello
<b>=&gt;</b> ? "hello";
hello
</pre>
<li>Compound statements (statements that enclose other statements) can be
used provided that the complete statement appears on a single line.
<pre>
<b>=&gt;</b> for i in 1..5 loop put_line( i ) ; end loop
1
2
3
4
5
</pre>
</li>
<li>During an assignment, if the variable being assigned isn't declared,
it's automatically declared unless <a href="bushtutorial.html#pragmas">pragma
ada_95</a> or <a href="bushtutorial.html#pragmas">pragma restriction(
no_auto_declarations )</a> is used. The type of the variable is the type of
the expression being assigned.
<pre>
<b>=&gt;</b> i := 5
<b>=&gt;</b> (Assuming i is a new universal_numeric variable)
</pre>
</li>
<li>External commands can be grouped into pipelines using the vertical
bar character (|).&nbsp; Pipelines are a command line convenience feature
and are not intended for use in scripts (this is true in other Linux shells
as well).</li>
</ul>
&nbsp;<br>

<p>Interactive sessions can only be terminated with the logout command.
<br>
</p>
<p><br>
</p>
<h3><a name="3.18"></a><font color="#777700">3.18 The Current Directory</font></h3>
There are two built-in BASH-style commands for managing your current
directory:

<p><b>pwd</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
<p>Display the path of the present (also called "current") working
directory.</p>
<u>Bash equivalent</u>: <tt>pwd</tt><br>
<u>Perl equivalent</u>: <tt>Cwd::getcwd</tt><br>
<u>PHP  equivalent</u>: <tt>getcwd</tt><br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>cd</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td align="left">
<p>Change the present working directory. The tilde, '~', represents your
home directory. The minus sign, '-', represents your previous directory.
The cd command ignores the value of a CDPATH variable.</p>
</p>
<p><u>Example</u></p>
<pre>
<b>=&gt;</b> pwd
/home/ken/ada/bush/doc
<b>=&gt;</b> cd ../src
<b>=&gt;</b> pwd
/home/ken/ada/bush/src
<b>=&gt;</b> cd -
/home/ken/ada/bush/doc
<b>=&gt;</b> cd ~/src
<b>=&gt;</b> pwd
/home/ken/src
</pre>
<u>Bash equivalent</u>: <tt>cd</tt><br>
<u>Perl equivalent</u>: <tt>chdir</tt><br>
<u>PHP  equivalent</u>: <tt>chdir</tt><br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<h3><a name="3.19"></a><font color="#777700">3.19 Database Commands</font></h3>
BUSH understands basic SQL commands.&nbsp; This feature is a great
convenience for people who work frequently with databases.&nbsp; The
SQL command parameters are given directly to your database.&nbsp; BUSH
recognizes the following SQL commands:<br>
<ul>
  <li><span style="font-weight: bold;">alter</span> - alter a database
table</li>
  <li><span style="font-weight: bold;">delete</span> - delete a row
from a database table</li>
  <li><span style="font-weight: bold;">insert</span> - add a row to a
database table</li>
  <li><span style="font-weight: bold;">select</span> - show the results
of a database query</li>
  <li><span style="font-weight: bold;">update</span> - edit a row in a
database table</li>
</ul>
SQL is a different language from AdaScript and the Bourne shell.&nbsp;
SQL for one database may not be compatible with another.&nbsp; For
example, an asterisk (*) will not expand to a list of files and quote
marks indicate strings or table names, not how to expand dollar
variables.&nbsp; Your database documentation will explain how to use
your version of SQL.<br>
<br>
BUSH submits the SQL command to the database with only one
change.&nbsp; Bush will search command for variables and will
substitute values using a dollar sign ($) and escape characters with a
backslash.&nbsp; Single and double
quotes have no effect on how the variable is substituted since quote
marks used for a different purpose in SQL.<br>
<br>
Like a shell command, the output from the database commands can be
redirected or captured using backquotes.&nbsp; The commands can be
intermixed with the db package database commands.<br>
<br>
For example,<br>
<br>
<span style="font-family: monospace;">=&gt; db.connect( "ken" )</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; select * from users</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;name&nbsp; | age</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">-------+------</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;ken&nbsp;&nbsp; | 38</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;dan&nbsp;&nbsp; | 37</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;chris | 40</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;kati&nbsp; | 36</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;4 Rows and 2 Columns<br>
=&gt; select * from users where user \&gt; 'dan'<br>
</span><span style="font-family: monospace;">&nbsp;name&nbsp; | age</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">-------+------</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;ken&nbsp;&nbsp; | 38</span><br
 style="font-family: monospace;">
&nbsp;
<span style="font-family: monospace;"></span><span
 style="font-family: monospace;">kati&nbsp; | 36</span><br
 style="font-family: monospace;">
&nbsp;
<span style="font-family: monospace;">2 Rows and 2 Columns</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; select count(*) from users
&gt; temp.tmp</span><br style="font-family: monospace;">
<span style="font-family: monospace;">=&gt; cat temp.tmp</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;count</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">-------</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;4<br>
=&gt; s : string := `select age from users;`<br>
=&gt;&nbsp; k := "ken"<br>
=&gt; (Assuming k is a new universal_string variable)<br>
=&gt; select * from users where name = '$k'<br>
&nbsp;name | age<br>
------+------<br>
&nbsp;ken&nbsp; | 38<br style="font-family: monospace;">
</span><span style="font-family: monospace;">=&gt; db.disconnect</span><br>
<br>
The format of select statements is the same as db.show in the db
package.<br>
<br>
Some limitations on database commands:<br>
<ul>
  <li>Database commands cannot (yet) be used in a pipeline<br>
  </li>
  <li>BUSH interprets &lt;, &gt;, &gt;&gt;, $, quotes and other symbols
(escape them when necessary using \)</li>
  <li>Database commands cannot be used with pragma ada_95 (use the db
library instead)<br>
  </li>
</ul>
<span style="font-family: monospace;"></span>
<br>
<h3><a name="3.20"></a><font color="#777700">3.20 Flow of Control</font></h3>
<p><br>
if statements are used for conditional branching.
</p>
<p><tt><b>if</b> x &gt; y <b>then</b></tt>
<br>
<tt>&nbsp;&nbsp; put_line( "x is greater than y" );</tt>
<br>
<tt><b>elsif</b> x = y <b>then</b></tt>
<br>
<tt>&nbsp;&nbsp; put_line( x is equal to y" );</tt>
<br>
<tt><b>else</b></tt>
<br>
<tt>&nbsp;&nbsp; put_line( x is less than y" );</tt>
<br>
<tt><b>end</b> <b>if</b>;</tt>
</p>
<p>The case statement can test a variable for several different values.
</p>
<p><tt><b>type</b> country <b>is</b> ( australia, u_k, brazil );</tt>
<br>
<tt>...</tt>
<br>
<tt><b>case</b> c <b>is</b></tt>
<br>
<tt><b>when</b> austraila =&gt;</tt>
<br>
<tt>&nbsp;&nbsp; put_line( "Australia" );</tt>
<br>
<tt><b>when</b> u_k =&gt;</tt>
<br>
<tt>&nbsp;&nbsp; put_line( "United Kingdom" );</tt>
<br>
<tt><b>when</b> brazil =&gt;</tt>
<br>
<tt>&nbsp;&nbsp; put_line( "Brazil" );</tt>
<br>
<tt><b>when</b> others =&gt;</tt>
<br>
<tt>&nbsp;&nbsp; put_line( "Unexpected country" );</tt>
<br>
<tt><b>end</b> <b>case</b>;</tt>
</p>
<p>Multiple cases can be strung together using a vertical bar (|).
</p>
<p><tt>&nbsp;&nbsp;<b>when</b> brazil | u_k =&gt; -- brazil or U.K.</tt>
</p>
<p>The "when" cases must not be variables (although constants are OK).
The
"when others" case is always required.
</p>
<p>The while loop is a pre-test loop.&nbsp; The commands in the loop
are
repeat while the condition is true and the condition is tested each
time
the first line of the loop is executed.
</p>
<p><tt>while x &gt; y loop</tt>
<br>
<tt>&nbsp; x := @ + 1;</tt>
<br>
<tt>end loop;</tt>
</p>
<p>The for loop increments its index variable by 1 until it iterates
through
the specified range. The index variable is automatically declared for
you
and only exists for the scope of the the loop.&nbsp; The range can
either
be numeric or enumerated.
</p>
<p><tt>for i in 1..10 loop</tt>
<br>
<tt>&nbsp; put( "i is " );</tt>
<br>
<tt>&nbsp; put_line( i );</tt>
<br>
<tt>end loop;</tt>
</p>
<p>To loop in reverse in a for loop, use "in reverse" instead of "in".
</p>
<p>Any loop can be exited by using either an exit statement or an "exit
when" shorthand.
</p>
<p><tt>if x &gt; 100 then</tt>
<br>
<tt>&nbsp; exit;</tt>
<br>
<tt>end if;</tt>
</p>
<p><tt>exit when x &gt; 100;</tt>
</p>
<p>A "loop" loop is a general purpose loop. It can only be exited with
"exit".
</p>
<p><tt>loop</tt>
<br>
<tt>&nbsp; reply := get_line;</tt>
<br>
<tt>&nbsp; exit when reply = "exit";</tt>
<br>
<tt>end loop;</tt>
<br>
&nbsp;
</p>
<h3><a name="3.21"></a><font color="#777700">3.21 Other
Statements/Subprograms</font></h3>
<p><b>null</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td>
<p>The null command doesn't do anything.  It acts as a placeholder in contexts
where commands are required.  There are no arguments.</p>
<p><u>Example</u>:</p>
<pre>
<b>if</b> x &gt; y <b>then</b>
   <b>null;</b> -- to be filled in later
<b>end</b> <b>if;</b>
</pre>
<u>GCC Ada equivalent</u>: <tt>null</tt><br>
<u>Bash equivalent</u>: <tt>:</tt><br>
<u>Perl equivalent</u>: <tt>N/A</tt><br>
<u>PHP  equivalent</u>: <tt>N/A</tt><br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<p><b>delay</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td>
<p>Delay (sleep) for a specific number of seconds.</p>
<p><u>Example</u>:</p>
<pre>
<b>=&gt;</b> delay 3.5; -- wait 3 and a half seconds
</pre>
<u>GCC Ada equivalent</u>: <tt>delay</tt><br>
<u>Bash equivalent</u>: <tt>sleep</tt><br>
<u>Perl equivalent</u>: <tt>sleep</tt><br>
<u>PHP  equivalent</u>: <tt>sleep</tt><br>
</td>
</tr>
</table>
</center>
&nbsp;<br>


The <b>nulue]</b></p>
<center>
<table border="0" cellspacing="0" cellpadding="0" width="90%" summary="">
<tr>
<td>
<p>Unconditionally terminate the script, procedure or function.&nbsp; Functions
must have a return value.  In an interactive shell, return will terminate
a shell that is not a login shell.</p>
<p><u>See Also</u>: logout</p>
<p><u>Example</u>:</p>
<pre>
<b>=&gt;</b> logout
logout;
^----^ warning: this is not a login shell: use return to quit
<b>=&gt;</b> return
</pre>
<u>GCC Ada equivalent</u>: <tt>return</tt><br>
<u>Bash equivalent</u>: <tt>return</tt> or <tt>exit</tt><br>
<u>Perl equivalent</u>: <tt>return</tt><br>
<u>PHP  equivalent</u>: <tt>return</tt><br>
</td>
</tr>
</table>
</center>
&nbsp;<br>

<h3><a name="3.22"></a><font color="#777700">3.22 External Commands</font></h3>
The purpose of an AdaScript script is, ultimately, to execute shell
commands.
Any command not understood by AdaScript as a command is assumed to be a
shell command. For example,
<p><tt>=&gt; echo</tt>
</p>
<p>will run the Linux echo command and print a blank line to the
screen,
the same as new_line.
</p>
<p>Commands are accepted in one of two different formats. If the
command
is followed by a "(", the parameters are expected to be in AdaScript
format
with each parameter separated by a comma (","). These parameters may be
any legitimate AdaScript expression and no shell quote removal or file
globbing is performed.
</p>
<p><tt>=&gt; ls( "bush.adb" )</tt>
<br>
<tt>bush.adb</tt>
</p>
<p>If the command is not followed by a "(", the parameters are expected
to be in Bourne shell format. This is provided for convenience in
interactive
sessions.&nbsp; The parameters are shell "words" separated by spaces.
Each
word has file globbing performed. The words may be enclosed in double
quotes
to allow embedded spaces, or single quotes to inhibit file globbing.
Special
characters may also be escaped with backslashes.
</p>
<p><tt>=&gt; ls b*.adb</tt>
<br>
<tt>builtins.adb bush.adb</tt>
</p>
<p>Bush can insert the values of variables using BASH-style "$"
substitutions.&nbsp; "ls $HOME" will show the contents of your home
directory.<br>
</p>
<p>Command names containing space characters can be quoted with double
quotes.
</p>
<p><tt>=&gt; "inventory report"</tt>
</p>
<p>When pragma ada_95 is used, shell commands must only use the
AdaScript
parameter format.
</p>
<p>External commands can be run in the background using an ampersand
("&amp;")
at the end of the command. With AdaScript parameters, place the
ampersand
after the closing parenthesis. The <b>jobs</b> command displays the
status
of any outstanding background commands.
</p>
<p>The built-in shell commands are listed in a section above. when a
Linux
command conflicts with a built-in command, the Linux command can be
executed
using the <b>command</b> command.
</p>
<p>The results of a command can be captured as a string using
backquotes.&nbsp;
The commands should be ended with a semi-colon.&nbsp; Commands
appearing
in backquotes will be syntax checked along with the rest of the
commands
in a script.
</p>
<p><tt>=&gt; date : string := `date;`</tt>
</p>
<p>If there is a trailing line feed (or carriage return/line feed for
Windows)
it will be removed.
</p>
<p>Standard input, standard error and standard output can be redirected
using the Text_IO package.</p>
<br>
&nbsp;
<br>
<h3><a name="3.23"></a><font color="#777700">3.23 Block
Statements and Subprograms</font></h3>
<p>Bush scripts can be organized using declare blocks, procedures and
functions.<br>
</p>
<p>Declare blocks allow variables to be declared in the executable part
of a script.&nbsp; A new block can be created without declaration any
variables by using begin...end without the declare section.<br>
</p>
<p style="font-family: monospace;"><span style="font-weight: bold;">declare</span><br>
&nbsp;&nbsp; i : integer := 5;<br>
<span style="font-weight: bold;">begin</span><br>
&nbsp;&nbsp; ? i;<br>
<span style="font-weight: bold;">end;</span><br>
</p>
<p>Repeatable blocks of instructions (like Perl sub or Python def) can
be created with the word procedure or function.&nbsp; A procedure is a
set of instructions with a name.&nbsp; A function is a set of
instructions with a name that returns a value so it can be used in an
expression.&nbsp; Like a declare block, local variables can be declared
before the word begin.</p>
<p>Procedures and functions cannot be forward declared (yet) as there
is
no way to handle forward parameters (yet).<br>
</p>
<p style="font-family: monospace;"><span style="font-weight: bold;">procedure</span>
print_title <span style="font-weight: bold;">is</span><br>
<span style="font-weight: bold;">begin</span><br>
&nbsp;&nbsp; put_line( "Script to Process New Orders" );<br>
&nbsp;&nbsp; new_line;<br>
<span style="font-weight: bold;">end</span> print_title;<br>
</p>
<p>Both procedures and functions can have parameters.&nbsp; The
parameters are what Ada refers to as "in" parameters: they give
additional information to a subprogram and are treated as
constants.&nbsp; The word "in" is optional before the type of parameter.</p>
<p style="font-family: monospace;"><span style="font-weight: bold;">function</span>
add_two( number : integer ) <span style="font-weight: bold;">return</span>
integer <span style="font-weight: bold;">is</span><br>
<span style="font-family: monospace; font-weight: bold;">begin</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; <span
 style="font-weight: bold;">return</span> number+2;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"><span style="font-weight: bold;">end</span>
add_two;</span><br>
&nbsp;<br>
<br>
</p>
<p>Procedures and functions can only declared inside the declaration section of
a script's main procedure block.</p>
<pre>
  <b>procedure</b> my_script <b>is</b>
     <b>procedure</b> my_proc <b>is</b> -- OK
  ...
  <b>end</b> my_script;
</pre>
<p>That is, they must be in a script that has a main procedure block.</p>
<pre>
  i : integer;
  i := 5;
  <b>procedure</b> my_proc <b>is</b> -- BAD
</pre>

<h3><a NAME="3.24"></a><font color="#777700">3.24 TCP/IP Sockets</font></h3>
Network sockets can be declared using socket_type variables. Most of the
file I/O functions will work with sockets as well as files.
<p>The main difference between a socket and a file is that sockets are
always "in" and "out". When opening a socket, do not specify a mode.
<p>The name of the socket is a string containing the name of the server
computer, followed by a colon and a port number. The port number is 80
(a web server) if no port is specified. Certain ports, such as those above
32767, are prohibited as a security precaution.
<p><tt>#!/bin/bush</tt>
<br><tt>-- download a web page</tt>
<p><tt>f : socket_type;</tt>
<br><tt>c : character;</tt>
<p><tt>open( f, "www.somewebserver.com" );</tt>
<p><tt>put( f, "GET /index.html HTTP/1.0" &amp; ASCII.CR &amp; ASCII.LF
);</tt>
<br><tt>put( f, "User-Agent: BUSHTest/1.0 (BUSHTest)" &amp; ASCII.CR &amp;
ASCII.LF );</tt>
<br><tt>put( f, ASCII.CR &amp; ASCII.LF );</tt>
<p><tt>loop</tt>
<br><tt>&nbsp; get( f, c );</tt>
<br><tt>&nbsp; put( c );</tt>
<br><tt>&nbsp; exit when end_of_file( f );</tt>
<br><tt>end loop;</tt>
<p><tt>put_line( "End of web page" );</tt>
<br><tt>close( f );</tt>
<br>&nbsp;
<h3>
<a NAME="3.25"></a><font color="#777700">3.25 Numeric Formatting with
Put</font></h3>
BUSH offers numeric formatting for numbers up to 18 digits and 4 decimal
places. Formatted numbers are written with the put command, not put_line.
Following the number, provide a formatting picture string describing how
the number should be formatted.
<p>The picture string may include:
<ul>
<li>
<b><tt>'+'</tt></b> - the number will be printed with a leading + or -</li>

<li>
<b><tt>'-'</tt></b> - a negative numbers will be printed with a leading
-</li>

<li>
<tt><b>'&lt;'</b> </tt>and<tt> <b>'>'</b></tt> - a negative number will
be printed with (..)</li>

<li>
<b><tt>"CR"</tt></b> - a negative number will be printed with a leading
"CR" (credit)</li>

<li>
<b><tt>"DB"</tt></b> - a negative number will be printed with a leading
"DB" (debit)</li>

<li>
<b><tt>'$'</tt></b> - the currency symbol will be printed, or a floating
dollar sign if multiple instances</li>

<li>
<b><tt>'.'</tt></b> - marks the actual position for a decimal point</li>

<li>
<b><tt>'V'</tt></b> - marks the assumed position for a decimal point</li>

<li>
<b><tt>'9'</tt></b> - space for a number with leading zeros</li>

<li>
<b><tt>'#'</tt></b> - same as '$', except only the leading character is
shown</li>

<li>
<tt><b>'Z'</b> </tt>- space for a numbers with leading blanks</li>

<li>
<b><tt>'_'</tt></b>, <b><tt>'B'</tt></b>, <b><tt>'0'</tt></b>, <b><tt>'/'</tt></b>-
inserted. 'B' is a blank</li>

<li>
<b><tt>'*'</tt></b> - space for a number with leading asterisks</li>
</ul>
Here are a few examples.
<p><tt>=&gt; put( 12.34, "***9.99" ) ; new_line</tt>
<br><tt>**12.34</tt>
<br><tt>=&gt; put( 12.34, "###9.99" ) ; new_line</tt>
<br><tt>&nbsp;$12.34</tt>
<br><tt>=&gt; put( 12.34, "+###9.99" ) ; new_line</tt>
<br><tt>+ $12.34</tt>
<br><tt>=&gt; put( 12.34, "-###9.99" ) ; new_line</tt>
<br><tt>&nbsp; $12.34</tt>
<br><tt>=&gt; put( 12.34, "&lt;###9.99&gt;" ) ; new_line</tt>
<br><tt>&nbsp; $12.34</tt>
<br><tt>=&gt; put( -12.34, "&lt;###9.99&gt;" ) ; new_line</tt>
<br><tt>( $12.34)</tt>
<br>&nbsp;
<br>&nbsp;
<h3>
<h3><a name="3.26"></a><font color="#777700">3.26 Interpreter Directives</font></h3>
Pragmas, or interpreter directives, provide additional instructions to
AdaScript.
<ul>
  <li> <b>pragma ada_95 </b>- requires the script syntax be as close
to
Ada 95
as possible, otherwise errors will occur.</li>
  <li> <b>pragma annotate( [type,] "text" )</b> - embed a comment. The
contents of any or all annotate pragmas are shown when you use the help
command on a script.  Type type of annotation field can be: author,
created, description, errors, modified, param, return,
see also, summary or version.</li>
  <li> <b>pragma assert( expression )</b> - evaluates the expression.
If
it isn't
true, the program stops and "assertion failed" is displayed.&nbsp;
Requires
--debug option or asserts will have no effect.</li>
  <li> <b>pragma debug( `commands` )</b> - these are a set of
debugging commands to run when debugging
is turned on with --debug.&nbsp; Make sure the final command ends with
a semi-colon.  Without a parameter, same as --debug (turn on debugging).
The debugging commands are run in restricted shell mode.</li>
  <li><b>pragma deprecated( "newscript" )</b>
- another name for pragma depreciated.<br>
  </li>
  <li> <b>pragma depreciated( "newscript" )</b> - when script finishes
execution,
BUSH will warn that the script is obsolete and has been superceded for
"newscript".</li>
  <li> <b>pragma export( shell, var )</b> - export a string variable
to
the O/S
environment. The first parameter must be "shell".</li>
  <li><span style="font-weight: bold;">pragma gcc_errors</span> - same
as --gcc-errors.&nbsp; Show simplified gcc-style errors.<br>
  </li>
  <li> <b>pragma import( shell | cgi, var )</b> - import a shell or
environment variable as
a Bush string variable. If the environment variable doesn't exist, BUSH
will report an error (see unchecked_import). The first parameter must
be
"shell".</li>
  <li> <b>pragma inspect( var )</b> - show a variable's description
(as if
'env var' was used) whenever a user breaks to a command prompt. Has no
effect if --break option isn't used.</li>
  <li> <b>pragma inspection_peek</b> - like inspection_point, displaying
inspect variables, except it doesn't break to a command prompt.</li>
  <li> <b>pragma inspection_point</b> - break to a command prompt as if
SIGINT (control-C) was received, displaying the call stack and any
variables marked for inspection with pragma inspect. Has no effect if
--break option isn't used. A "breakpoint".</li>
  <li><span style="font-weight: bold;">pragma no_command_hash</span> -
Bush normally remembers the location of a command once it has found
it.&nbsp; This pragma forces Bush to search for the location of the
command, ignoring the previous location.<br>
  </li>
  <li> <b>pragma prompt_script( `commands` )</b> - commands to draw
the
command
prompt.&nbsp; If the string is an empty string, the default "=&gt;"
prompt
is used.&nbsp; Make sure the final command ends with a
semi-colon.&nbsp; Changing your prompt will also change the title of
your terminal window.<br>
  </li>
  <li> <b>pragma restriction( no_auto_declarations )</b> - disable
automatic declaration
at the command prompt</li>
  <li> <b>pragma restriction( no_external_commands )</b> - disable
operating system
commands. Provides portability by ensuring no commands besides BUSH's
built-in
commands are executed. Useful for applications using BUSH as a run-time
scripting language and not for shell scripting.</li>
  <li> <b>pragma template( text|html [, template] )</b> - BUSH will
act
like an HTML
template processor (like PHP). When the script finishes executing, BUSH
will open a file called "file.tmpl" where file is the name of the
script.
If an alternate file path is included in the pragma, that file is used
as the
template instead. A HTTP header is written and BUSH parses the template
along with any embedded scripts. For security, the embedded scripts in
the template will be run in a restricted shell and with the
no_external_commands restriction. Errors are shown in --gcc-errors
format
using the line number in the template as the line number for the error.
The first parameter is the template type: "text" or "html".</li>
  <li> <b>pragma unchecked_import( shell | cgi, var )</b> - import a
CGI or
environment variable
as a BUSH string variable. If the environment variable doesn't exist,
then
the BUSH variable is unchanged. The first parameter must be "shell".</li>
  <li> <b>pragma uninspect( var )</b> - undo a pragma inspect. Don't
show
a
variable's description whenever a user breaks to a command prompt. Has
no
effect if --break option isn't used.</li>
  <li> <b>pragma unrestricted_template( text|html [, template] )</b> -
BUSH will act
like an HTML template processor (like PHP). This pragma is the same as
pragma template except that the embedded scripts are executed in a
normal
shell with no security restrictions.</li>
  <li> <b>pragma volatile( var )</b> - the variable is assumed to be
an
environment
variable which may change during the script's execution. The variable's
value will be updated each time it is referenced in an expression. Only
makes sense if the variable is imported as well.</li>
</ul>
<h3>
<a name="3.27"></a><font color="#777700">3.27 Command Line Options</font></h3>
There are several command options for BUSH.
<p></p>
<center><img src="bush_4.gif" alt="[BUSH screenshot]" height="227"
 width="591">
</center>
<ul>
  <li> <b>--break (or -b)</b> - allow breakout to a shell prompt on a
SIGINT or
a script error. (e.g. a control-c will give you a shell prompt.) Use
"return"
to continue execution or "logout" to terminate script.</li>
  <li> <b>--check (or -c)</b> - check the syntax of a script but do
not
run the
script</li>
  <li> <b>--debug (or -d)</b> -&nbsp; enable pragma debug's and
assert's.&nbsp;
Without this, the pragmas have no effect.</li>
  <li> <b>--exec (or -e)</b> -&nbsp; the script path is not a path but
a
script to
execute.</li>
  <li> <b>--gcc-errors (or -g)</b> - show simple gcc-style error
messages
to be
compatible with smart editors and IDEs. Also disables bold and inverse
printing in error messages.</li>
  <li> <b>--help (or -h)</b> - show help on command line options</li>
  <li> <b>--import-all (or -n)</b> - declare and import all
environment
variables
when BUSH starts</li>
  <li> <b>--login (or -l)</b> - simulate a login shell</li>
  <li> <b>--no-check (or -n)</b> - run without checking the syntax
first</li>
  <li> <b>--restricted (or -r)</b> - run as a restricted shell.</li>
  <li> <b>--trace (or -x)</b> - same as "trace true". Turn on tracing.</li>
  <li> <b>--verbose (or -v)</b> - show interpreter progress</li>
  <li> <b>--version (or -V)</b> - show version of BUSH and exit</li>
  <li> <b>--</b> - explicitly end of shell options</li>
</ul>
<h3>
<a name="3.28"></a><font color="#777700">3.28 Command Reference</font></h3>
Here is a list of the AdaScript built-in commands and statements.
Commands
found in the built-in packages are documented in Part 4.
<p><b>begin</b>
</p>
<p>see <b>declare</b>
</p>
<p><b>case</b>
</p>
<p>Syntax: case var is when constant|literal =&gt; ... when others
=&gt; ...
end case
<br>
Description: Test a variable for multiple values. "when others" case
is required.
</p>
<p><b>cd</b>
</p>
<p>Syntax: cd - | dirname
<br>
Description: change directory. "-" is the previous directory.&nbsp;
A leading '~' is your home directory.
</p>
<p><b>clear</b>
</p>
<p>Syntax: clear
<br>
Description: reset tty device and clear the screen
</p>
<p><b>close</b>
</p>
<p>Syntax: close( file )
<br>
Description: close an open file
</p>
<p><b>command [prior to Bush 1.0]</b>
</p>
<p>Syntax: command cmd
<br>
Description: run a Linux command (instead of a built-in command).
</p>
<p><b>create</b>
</p>
<p>Syntax: create( file [, out_file | append_file] [, path ] )
<br>
Description: create - create a new file or overwrite an existing file.
The default type is out_file. The default path a temporary file name.
</p>
<p><b>declare</b>
</p>
<p>Syntax: [declare declarations] begin ... end
<br>
Description: begin a new block
</p>
<p><b>delay</b>
</p>
<p>Syntax: delay secs
<br>
Description: wait (sleep) for a specific time
</p>
<p><b>delete</b>
</p>
<p>Syntax: delete( file )
<br>
Description: close and delete a file
</p>
<p><b>end_of_file</b>
</p>
<p>Syntax: end_of_file( file )
<br>
Description: true if an in_file file has no more data
</p>
<p><b>end_of_line</b>
</p>
<p>Syntax: end_of_line( file )
<br>
Description: true if an in_file file has reached the end of a line
with get
</p>
<p><b>else</b>
</p>
<p>see <b>if</b>
</p>
<p><b>elsif</b>
</p>
<p>see <b>if</b>
</p>
<p><b>env</b>
</p>
<p>Syntax: env or env identifier or env (identifier)
<br>
Description: show a table of all identifiers, or identify an identifier
or
keyword.
</p>
<p><b>exit</b>
</p>
<p>Syntax: exit | exit when condition
<br>
Description: break out of a loop
</p>
<p><b>for</b>
</p>
<p>Syntax: for var in [reverse] first..last loop ... end loop
<br>
Description: for loop - loop through between first and last assigning
value to var. The for starts a new block and the for variable is
automatically
declared based on the type of first.
</p>
<p><b>get</b>
</p>
<p>Syntax: get( [file,] var )
<br>
Description: read a character from a line of text.
</p>
<p><b>get_line</b>
</p>
<p>Syntax: var := get_line [ (file) ]
<br>
Description: read a line of text
</p>
<p><b>history</b>
</p>
<p>Syntax: history -c | history [n]
</p>
<p>Show or clear the interactive command history.&nbsp; If n, show the
n most recent interactive commands.<br>
</p>
<p><b>if</b>
</p>
<p>Syntax: if expression then ... [elsif expr then ...] [ else ...]
<br>
Description: conditional execution
</p>
<p><b>inkey</b>
</p>
<p>Syntax: c := inkey
<br>
Description: read a character from standard input without echoing
</p>
<p><b>is_open</b>
</p>
<p>Syntax: is_open( file )
<br>
Description: true if file is open
</p>
<p><b>jobs</b>
</p>
<p>Syntax: jobs
<br>
Description: list status of current background jobs
</p>
<p><b>line</b>
</p>
<p>Syntax: line( file )
<br>
Description: the number of read/written lines
</p>
<p><b>logout</b>
</p>
<p>Syntax: logout
<br>
Description: terminate an interactive login session
</p>
<p><b>loop</b>
</p>
<p>syntax: loop ... end loop
<br>
Description: General loop. exit with an exit statement.
</p>
<p><b>mode</b>
</p>
<p>Syntax: mode( file )
<br>
Description: the file mode (in_file, out_file, append_file)
</p>
<p><b>name</b>
</p>
<p>Syntax: name( file )
<br>
Description: name of an open file
</p>
<p><b>new_line</b>
</p>
<p>Syntax: new_line [(file)]
<br>
Description: start a new line
</p>
<p><b>null</b>
</p>
<p>Syntax: null
<br>
Description: do nothing
</p>
<p><b>open</b>
</p>
<p>Syntax: open( file, in_file | out_file | append_file, path )
<br>
Description: open an existing file or open a socket
</p>
<p><b>pragma</b>
</p>
<p>interpreter directive
</p>
<p><b>put</b>
</p>
<p>Syntax: put ( [file], expression [, picture] )
<br>
Description: write to output, no new line. If picture is included,
format the number according to the picture.
</p>
<p><b>put_line</b>
</p>
<p>Syntax: put_line ( [file], expression )
<br>
Display: write to output and start new line
</p>
<p><b>pwd</b>
</p>
<p>Syntax: pwd
<br>
Description: present working directory
</p>
<p><b>reset</b>
</p>
<p>Syntax: reset( file [,mode]
<br>
Description: reopen a file
</p>
<p><b>return</b>
</p>
<p>Syntax: return [status code]
<br>
Description: exit script and return status code
</p>
<p><b>set_input</b>
</p>
<p>Syntax: set_input( file ), set_output( file ), set_error( file )
<br>
Description: input/output redirection
</p>
<p><b>skip_line</b>
</p>
<p>Syntax: skip_line [(file)]
<br>
Description: discard the next line of input
</p>
<p><b>subtype</b>
</p>
<p>Syntax: subtype newtype is oldtype
<br>
Description: create an alias for a type
</p>
<p><b>system</b>
</p>
<p>Syntax: system( commandstring )
<br>
Description: run a BASH shell command
</p>
<p><b>trace</b>
</p>
<p>Syntax: trace [true | false]
<br>
Description: show verbose debugging information
</p>
<p><b>typeset</b>
</p>
<p>Syntax: typeset var [is type]
<br>
Description: change the type of a variable, declaring it if necessary.
Cannot be used in scripts or with pragma ada_95.
</p>
<p><b>unset</b>
</p>
<p>Syntax: unset ident or unset (ident)
<br>
Description: delete an identifier. Cannot be used in scripts or with
pragma ada_95.
</p>
<p><b>wait</b>
</p>
<p>Syntax: wait
<br>
Description: wait for all background commands to finish.
</p>
<p><b>while</b>
</p>
<p>Syntax: while condition loop ... end loop
<br>
Description: while loop - repeat the loop until the condition is false
</p>
<p><b>?</b>
</p>
<p>Syntax: ? expression
<br>
Description: put_line to standard output. Cannot be used with pragma
ada_95.
</p>
<h3><a name="3.29"></a><font color="#777700">3.29 ASCII Character Set</font></h3>
The ASCII character set is represented by the ASCII enumerated type, characters 0 to 127.  The Latin_1 character set is another character set for characters 0 to 255.  The following is the complete ASCII set:
<p>ASCII.NUL - control-@
<br>
ASCII.SOH - control-A
<br>
ASCII.STX - control-B
<br>
ASCII.ETX - control-C
<br>
ASCII.EOT - control-D
<br>
ASCII.ENQ - control-E
<br>
ASCII.ACK - control-F
<br>
ASCII.BEL - control-G
<br>
ASCII.BS - control-H
<br>
ASCII.HT - control-I
<br>
ASCII.LF - control-J
<br>
ASCII.VT - control-K
<br>
ASCII.FF - control-L
<br>
ASCII.CR - control-M
<br>
ASCII.SO - control-N
<br>
ASCII.SI - control-O
<br>
ASCII.DLE - control-P
<br>
ASCII.DC1 - control-Q
<br>
ASCII.DC2 - control-R
<br>
ASCII.DC3 - control-S
<br>
ASCII.DC4 - control-T
<br>
ASCII.NAK - control-U
<br>
ASCII.SYN - control-V
<br>
ASCII.ETB - control-W
<br>
ASCII.CAN - control-X
<br>
ASCII.EM - control-Y
<br>
ASCII.SUB - control-Z
<br>
ASCII.ESC - Escape key
<br>
ASCII.FS
<br>
ASCII.GS
<br>
ASCII.RS
<br>
ASCII.US
<br>
ASCII.DEL - ASCII 127, delete key
<br>
ASCII.Exclam - "!"
<br>
ASCII.Quotation - """"
<br>
ASCII.Sharp - "#"
<br>
ASCII.Dollar - "$"
<br>
ASCII.Percent - "%"
<br>
ASCII.Ampersand - "&amp;"
<br>
ASCII.Colon - ":"
<br>
ASCII.Semicolon - ";"
<br>
ASCII.Query - "?"
<br>
ASCII.At_Sign - "@"
<br>
ASCII.L_Bracket - "["
<br>
ASCII.Back_Slash - "\"
<br>
ASCII.R_Bracket - "]"
<br>
ASCII.Circumflex - "^"
<br>
ASCII.Underline - "_"
<br>
ASCII.Grave - "`"
<br>
ASCII.L_Brace - "{"
<br>
ASCII.Bar - "|"
<br>
ASCII.R_Brace - "}"
<br>
ASCII.Tilde - "~"
<br>
ASCII.UC_A - "A"
<br>
...
<br>
ASCII.UC_Z - "Z"
<br>
ASCII.LC_A - "a"
<br>
...
<br>
ASCII.LC_Z - "z"
<br>
<h3><a name="3.30"></a><font color="#777700">3.30 Common Error Messages</font></h3>
<b>@ is not allowed with pragma ada_95</b> - @ (itself) is not an Ada
95
feature. Fill in the actual variable name.
<br>
<b>% is not allowed with pragma ada_95</b> - % (last output) is not
an Ada 95 feature.
<br>
<b>$# not allowed with pragma ada_95</b> - $# is not an Ada 95 feature.
Use the command_line package instead.
<br>
<b>$0 not allowed with pragma ada_95</b> - $0 is not an Ada 95 feature.
Use the command_line package instead.
<br>
<b>$1..$9 not allowed with pragma ada_95</b> - $1 to $9 are not an
Ada 95 feature. Use the command_line package instead.
<br>
<b>absolute paths to commands not allowed in restricted shells</b>
- absolute paths are a security risk because they allow a restricted
shell
or script to run any command (provided they have permission to do so).
<br>
<b>access to this TCP/IP port is prohibited</b> - certain URL port
numbers are reserved for special functions or are non-standard across
different
operating systems. Choose a different port number.
<br>
<b>alias isn't supported</b> - since BUSH has no access types, the
Ada keyword alias isn't supported by BUSH.
<br>
<b>already declared</b> - the name is already defined in the symbol
table as something else
<br>
<b>assertion failed</b> - the condition for the assert pragma evaluated
to false.
<br>
<b>boolean expression expected</b> - BUSH was expected something that
equates to "true" or "false" but found something else instead. For
example,
"if 2+2 then". Check your expression.
<br>
<b>boolean operator expected</b> - BUSH was expecting a AND, OR or
XOR. Usually indicates something is missing in the command.
<br>
<b>Bourne shell-style parameters not allowed with pragma ada_95</b>
- Bourne shell parameters are not a feature of Ada 95. Use Ada-style
parameters
instead.
<br>
<b>Break</b> - a <i>pragma inspection_point</i> was encountered, or
the program was interrupted with control-c (SIGINT).
<br>
<b>cannot create an in file</b> - a file must first have data written
to it before it can be read. You cannot read a newly created file.
<br>
<b>cd is not allowed in a restricted shell</b> - <i>cd</i> is a
security
risk because the user or script can run different commands if they
change
their current directory.
<br>
<b>character literal more than 1 character</b> - single quotes denote
a character literal such as 'a' or '1'. Double quotes denote strings of
more one or more characters.
<br>
<b>command types not allowed with pragma ada_95</b> - command types
are not a feature of Ada 95. Try implementing them as strings.
<br>
<b>command variables must be constant</b> - commands can only be
declared
as a <i>constant</i>.
<br>
<b>create not allowed in a restricted shell</b> - restricted shells
and scripts cannot create new files.
<br>
<b>current directory not assessible / doesn't exist</b> - your current
directory was deleted or had its permissions changed.
<br>
<b>else without if</b> - BUSH is unable to find the <i>if</i> that
belongs to your <i>else</i>. Check the structure of your if's.
<br>
<b>elsif without if</b> - same as above.
<b>end of file</b> - your
program has attempted to read past the end of the file
<br>
<b>end_of_file only applies to in_mode files</b> - the end_of_file
function only applied when reading files. When writing or appending to
files, you are always at the end of file.
<br>
<b>exception raised</b> - the operation was not permitted. For example,
dividing by zero or doing arithmetic with a variable that has no value.
<br>
<b>file already open</b> - the file_type variable was already opened
by
<i>open</i> or <i>create</i> but it must be closed before it is
reopened.
<br>
<b>file not open</b> - the file_type variable hasn't been opened yet
with
<i>open</i> or <i>create</i>.
<br>
<b>file_type expected</b> - BUSH was expected a file_type variable
in an open, create, etc. command. Check the type and order of your
parameters.
<br>
<b>file_type or socket_type variable expected</b> - same as above.
<br>
<b>functions not implemented</b> - user-defined functions are not yet
implemented
<br>
<b>invalid based numeric literal</b> - usually specifying a base and
using number characters larger than the base allows
<br>
<b>is not an executable command</b> - the command cannot be found or
you do not have permission to run it.
<br>
<b>limited types cannot be assigned a value</b> - limited types are
assigned values by BUSH. They cannot be assigned values.
<br>
<b>missing statement or command</b> - block statements must contain
statements or commands. Use the <i>null</i> command if there are no
statements
or commands.
<br>
<b>no &amp; - final piped command always runs in the foreground</b>
- the last command in a pipeline cannot have a &amp; (run in
background).
(This is also true in BASH.)
<br>
<b>no &amp; - piped commands are automatically run the the background</b>
- commands being piped don't need a &amp; (run in background) since
they
must always run in the background. The &amp; is implicit.
<br>
<b>no enclosing loop to exit</b> - <i>exit</i> was used while not in
a loop. If you want to quit an interactive session, use <i>logout</i>.
<br>
<b>no such argument</b> - the $1..$9 you are referning to doesn't
exist.
<br>
<b>not declared</b> - the name has not been defined in the symbol
table.
Often indicates a spelling mistake
<br>
<b>number format picture string expected</b> - the <i>put</i> appears
to be a formatted put, but there is no format picture or the picture
isn't
a string.
<br>
<b>number not a valid format picture</b> - the number cannot be
displayed
using the format picture string. For example, the number is too big.
<br>
<b>numeric or enumerated type expected</b> - for loops can only loop
over numeric or enumerated ranges. For example, <i>for s in "a".."z"
loop</i>
is a string range.
<br>
<b>only numeric types can use a format picture</b> - Only numeric
values
can be put with formatting. Strings or other types cannot be used.
<br>
<b>operation (something) not defined for these types</b> - In this
context, the arithmetic operation doesn't make sense. For example,
using
** for two strings.
<br>
<b>operation not defined for string types</b> - for example, attempting
to multiply two strings
<br>
<b>operator expected</b> - BUSH was expected an arithmetic operator
like +. Usually indicates something missing in the command.
<br>
<b>out_file mode not allowed in a restricted shell</b> - files cannot
be overwritten in restricted scripts or shells.
<br>
<b>packages not implemented</b> - user-defined packages are not yet
implemented
<br>
<b>pathname should not be null</b> - empty pathnames ("") are now
allowed.
Omit the pathname if you want BUSH to create a temporary name, or check
your string to find out why the pathname is missing.
<br>
<b>pipelines are not allowed with pragma ada_95</b> - pipelines ("|")
are not a feature of Ada 95. Use pipe files or share the results using
a temporary file.
<br>
<b>possible type of</b> - the name has not been defined in the symbol
table but appears to be similar to the spelling of another, defined
name.
<br>
<b>procedures not implemented</b> - user-defined procedures are not
yet implemented
<br>
<b>protected types not implemented</b> - AdaScript doesn't implement
Ada's protected types because there is no multithreading.
<br>
<b>return cannot return a status code with pragma ada_95. use
command_line
package</b> - Bourne shell's <i>return</i> can return a status code,
but
Ada's <i>return</i> does not permit a status code.
<br>
<b>sockets don't have a mode</b> - socket_type variables are always
in and out simultaneously. Don't specify a mode.
<br>
<b>standard_input (or output or error) cannot be assigned to (output
or input)</b> - standard input can only be read. Standard output and
error
can only be written.
<br>
<b>tasks not implemented</b> - AdaScript doesn't implement Ada's tasks
or task types because there is no multithreading.
<br>
<b>this file is the current (input/output/error) file</b> - you cannot
close standard input, output or error. For example, BUSH will not allow
you to close the keyboard in an interactive session.
<br>
<b>this is not an interactive shell--use return</b> - <i>logout</i>
is not permitted in scripts because you are not "logged in".
<br>
<b>too many identifiers (symbol table overflow)</b> - BUSH has no space
to declare any more identifiers. Your program has too many variables
declared.
Try breaking up the variables with <i>declare</i> blocks.
<br>
<b>too many nested statements (block table overflow)</b> - there are
too many nested block statements. For example, very many <i>if</i>
statements
with no <i>end if</i>.
<br>
<b>type name expected, not a number</b> - for example, expected <i>integer</i>
but found a <i>14</i> instead<b>type name expected, not a string
literal</b>
- for example, expected
<i>integer</i> but found <i>"hello world!"</i>
instead<b>type name expected, not a keyword</b> - for example, expected
<i>integer</i>
but found <i>then</i> instead<b>type name expected, not a symbol</b> -
for example, expected <i>integer</i> but found a semicolon<b>typeset
is
not allowed with pragma ada_95</b> - <i>typeset</i> is not a feature
of
Ada 95. Use a different variable with a new type.
<br>
<b>typeset is only allowed in an interactive session</b> - <i>typeset</i>
is an interactive session convenience. It is not intended for use in
scripts
because it makes scripts difficult to read.
<br>
<b>unable to allocate memory to call command</b> - your system is out
of (virtual) memory.
<br>
<b>unable to open file</b> - the operating system report a problem
while opening the file. For example, you may not have permission to
open
the file or the file has been locked by someone else.
<br>
<b>unable to interpret TCP/IP host</b> - the format of the URL is
wrong.
For example, a missing hostname may cause this error.
<br>
<b>unable to interpret TCP/IP port</b> - the format of the URL is
wrong.
For example, a colon without a port number may cause this error.
<br>
<b>unable to open socket</b> - BUSH was unable to establish a socket
to the URL. For example, your Internet connection may be down or the
host
name is spelled wrong.
<br>
<b>unable to delete file</b> - the operating system reported a problem
while deleting the file. For example, the file may have been deleted by
someone else already.
<br>
<b>unable to read file</b> - the operating system reported a problem
while reading the file. For example, the file may have been deleted by
someone else.
<br>
<b>unable to set input (or output or error)</b> - the operating system
reports that the file cannot be made into the current source of input
or
output.
<br>
<b>unable to write file</b> - the operating system reported a problem
while writing the file. For example, the file may have been locked by
someone
else to prevent writing.
<br>
<b>unexpected arguments after &amp;</b> - when a command is run in
the background using &amp;, the &amp; must be the last symbol.
<br>
<b>universal/typeless types not supported by pragma ada_95</b> -
universal
types are not a feature of Ada 95. Use other types instead.
<br>
<b>unset is not allowed with pragma ada_95</b> - <i>unset</i> is not
an Ada 95 feature.
<br>
<b>unset only allowed in interactive sessions</b> - unset cannot be
used in scripts. It is a interactive session convenience.
<br>
<b>unsetting PATH is not allowed in a restricted shell</b> - changing
PATH is a security risk because it changes what programs can be run
from
the restricted shell or script.
<br>
<b>use not implemented</b> - this Ada command is not yet implemented.
<br>
<b>variable/value expected</b> - BUSH found a keyword but was expecting
a variable or a literal. Usually indicates something missing in the
command.
<br>
<b>variable not allowed as a case</b> - in a case statement, <i>when</i>
cases cannot contain variables.
<br>
<b>warning: This is an interactive shell. Use logout.</b> - Use logout
to stop an interactive session, not <i>return</i>.
<br>
<b>when others expected</b> - case statements must always have a <i>when
others</i> part.
<br>
<b>with not implemented</b> - this Ada command is not yet implemented.<br>
&nbsp;<br>
<h3><a name="3.31"></a><font color="#777700">3.31 Common PHP Functions and the BUSH Equivalent</font></h3>

<pre>
<i>Arrays</i>

          <b>PHP</b>          <b>BUSH Equivalent</b>
          array_sum    arrays.sum
          asort        arrays.bubble_sort
                       arrays.heap_sort
          count        arrays.length
          shuffle      arrays.shuffle
          rsort        arrays.bubble_sort_descending
                       arrays.heap_sort_descending

<i>Numbers</i>

          <b>PHP</b>          <b>BUSH Equivalent</b>
          abs          abs
          acos         numerics.arccos
          acosh        numerics.arccosh
          asin         numerics.asin
          asinh        numerics.asinh
          atan         numerics.atan
          atanh        numerics.atanh
          base_convert #base#
                       put
          bindec       #base#
                       put
          ceil         numerics.ceiling
          cos          numerics.cos
          cosh         numerics.cosh
          decbin       #base#
                       put
          dechex       #base#
                       put
          decoct       #base#
                       put
          deg2rad      use appropriate cycle
          exp          numerics.exp
          floor        numerics.floor
          fmod         numerics.remainder
          hexdec       #base#
                       put
          log10        numerics.log
          log          numerics.log
          max          stats.max
                       numerics.max
          min          stats.min
                       numerics.min
          octdec       #base#
                       put
          pi           numerics.pi
          pow          **
          rad2deg      use appropriate cycle
          rand         numerics.random
                       numerics.rnd
          round        numerics.rounding
                       numerics.unbiased_rounding
          sin          numerics.sin
          sinh         numerics.sinh
          sqrt         numerics.sqrt
          tan          numerics.tan
          tanh         numerics.tanh

<i>Strings</i>

          <b>PHP</b>          <b>BUSH Equivalent</b>
          chr         strings.val
          substr_count strings.count
          echo        put
                      put_line
                      new_line
          explode     strings.field
                      strings.lookup
                      strings.csv_field
                      strings.delete
                      strings.insert
          implode     strings.replace
                      strings.csv_replace
                      strings.delete
                      strings.insert
          ltrim       strings.trim
          md5         strings.md5
          rtrim       strings.trim
          ord         strings.pos
          printf      put
          strpos      strings.index
          str_pad     strings.head
          str_repeat  *
          str_replace strings.replace
                      strings.replace_slice
                      strings.delete
                      strings.insert
          strstr      strings.pos
          strchr      strings.pos
          substr      strings.head
                      strings.tail
                      strings.slice
                      strings.element
          strlen      strings.length
          trim        strings.trim
          strtolower  strings.to_lower
          strtoupper  strings.to_upper
          locateconv  strings.to_basic
          ucwords     strings.to_proper
          wordwrap    strings.split
</pre>

<hr>
<p>&nbsp;<a href="#top">Back to Top</a></p>
</body>
</html>
