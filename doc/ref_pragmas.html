<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/transitional.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <META NAME="description" CONTENT="SparForte language documentation">
	<title>SparForte - Reference - Interpreter Directives</title>
	<link rel="StyleSheet" type="text/css" media="screen" href="art/sparforte.css">
</head>
<body bgcolor="#FFFFFF"><a name="top"></a>
	<table width="100%" cellspacing="0" cellpadding="0" summary="page layout">
		<tr><td align="left"><img src="art/sparforte.png" alt="[SparForte]"></td><td align="right"><img src="art/header_cloud.png" alt="[Banner]"></td></tr>
		<tr><td background="art/header_border.png" height="10" colspan="2"></td></tr>
		<tr><td colspan="2"><table width="100%" border="0" cellspacing="0" cellpadding="0" summary="top menu">
			<tr>
				<td width="10"><img src="art/menu_left.png" alt="[Top Main Menu]"></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="intro_preface.html">Intro</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="tutorial_1.html">Tutorials</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="ref_adascript.html"><b>Reference</b></a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="packages.html">Packages</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="../examples/index.html">Examples</a></td>
				<td background="art/menu_border.png" align="center"><span class="menutext">|</span></td>
				<td width="85" background="art/menu_border.png" align="center"><a class="menutext" href="cont_vision.html">Contributors</a></td>
				<td background="art/menu_border.png" align="center">&nbsp;</td>
				<td background="art/menu_border.png" align="right"><a href="ref_numberformat.html"><img src="art/left_arrow.png" width="27" height="24" alt="[Back Page]" border="0"></a><span class="menutext">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="ref_cmdoptions.html"><img src="art/right_arrow.png" width="27" height="24" alt="[Next Page]" border="0"></a></td>
				<td background="art/menu_border.png">&nbsp;</td>
</tr></table></td></tr>
	</table>
	<noscript>
	<a href="#submenu">[Jump to Submenu]</a>
	<hr />
	</noscript>
	<table width="100%" border="0" cellspacing="0" cellpadding="0" summary="content and right submenu">
		<tr>
			<td align="left" valign="top">
	<!-- Content Area -->
<h2><a name="3.26"></a>Interpreter Directives</font></h2>

<p>Pragmas, or interpreter directives, provide additional instructions to
AdaScript.  This section also contains information on importing variables to
and exporting variables from other software, such as the operating system
environment.</p>

<h3>The Pragmas</h3>

        <center>
        <div class="code">
<pre>
  <b>pragma</b> ada_95
  <b>pragma</b> annotate( [type,]"text" )
  <b>pragma</b> assert( condition )
  <b>pragma</b> debug( `commands` )
  <b>pragma</b> depreciated/deprecated( "newscript" )
  <b>pragma</b> export( shell | local_memcache | memcache , var )
  <b>pragma</b> gcc_errors
  <b>pragma</b> import( shell | cgi | local_memcache | memcache, var )
  <b>pragma</b> inspect( var )
  <b>pragma</b> inspection_peek
  <b>pragma</b> inspection_point
  <b>pragma</b> license( license_name [, extra] )
  <b>pragma</b> no_command_hash
  <b>pragma</b> prompt_script( `commands` )
  <b>pragma</b> restriction( annotations_not_optional )
  <b>pragma</b> restriction( no_annotate_todos )
  <b>pragma</b> restriction( no_auto_declarations )
  <b>pragma</b> restriction( no_external_commands )
  <b>pragma</b> restriction( no_memcache )
  <b>pragma</b> restriction( no_mysql_database )
  <b>pragma</b> restriction( no_postgresql_database )
  <b>pragma</b> template( css|html|js|json|text|wml|xml [, path] )
  <b>pragma</b> test( `commands` )
  <b>pragma</b> test_result( condition )
  <b>pragma</b> unchecked_import( shell | cgi | local_memcache | memcache, var )
  <b>pragma</b> uninspect( var )
  <b>pragma</b> unrestricted_template( css|html|js|json|text|wml|xml [, path] )
  <b>pragma</b> volatile( var )
</pre>
                <br>&nbsp;<br>
        <div class="code_caption">
                <b>Help Command</b>: The List of Pragmas</span>
        </div>
        </div>
	</center>

<h4>Architectural Pragmas</h4>

<p>Interpreter directives addressing business concerns, data design,
application design, technical design / use-of-hardware or the overall
vision of a project.  This includes portability, standards compliance,
licensing and feature restriction.</p>

<ul>
  <li> <b>pragma ada_95 </b>- requires the script syntax be as close
  to Ada 95 as possible, otherwise errors will occur.</li>
  <li><b>pragma deprecated( "newscript" )</b>
- another name for pragma depreciated.<br>
  </li>
  <li> <b>pragma depreciated( "newscript" )</b> - when script finishes
execution,
SparForte will warn that the script is obsolete and has been superceded for
"newscript".</li>
  <li><b>pragma license( license_name [, "extra"] )</b> - declare the
license for the script.  license_name can be:<br>
<ul>
<li><b>agpl</b> - Affero GPL</li>
<li><b>apache</b> - Apache Software License v1.0</li>
<li><b>apache_2</b> - Apache Software License v2.0</li>
<li><b>artistic</b> - Artistic License</li>
<li><b>bsd_original</b> - BSD License (Original)</li>
<li><b>bsd_revised</b> - BSD License (Revised)</li>
<li><b>commercial</b> - A commercial license</li>
<li><b>freeware</b>- A freeware license</li>
<li><b>gpl</b> - GNU General Public License</li>
<li><b>gplv2</b> - GNU General Public License v2.0</li>
<li><b>gplv3</b> - GNU General Public License v3.0</li>
<li><b>mit</b> - MIT License</li>
<li><b>public_domain</b> - Public Domain</li>
<li><b>restricted</b> - An restricted license</li>
<li><b>shareware</b> - A shareware license</li>
<li><b>unrestricted</b> - An unrestricted license</li>
</ul>
If extra exists, it is a string further describing the license (for example,
commercial/"trial license" or commercial/"15 users".  The extra string
can also be a URL to a complex license.<br>
<u>GCC Ada</u>: unrestricted, gpl and unrestricted are recognized by Ada.  It
doesn't support the extra string.  It treats these as levels and will
try to validate license compatibility where possible.</li>
  <li> <b>pragma restriction( annotations_not_options )</b> - if no pragma
annotate's are in the script, report an error after the script runs.
This is indended as a way to require developers to write
documentation.</li>
  <li> <b>pragma restriction( no_annotate_todos )</b> - if pragma
annotate todo is used, report an error after the script runs.  This
is intended for use in UAT or production environments where all
"todo" work should be completed earlier.</li>
  <li> <b>pragma restriction( no_auto_declarations )</b> - disable
automatic declaration
at the command prompt</li>
  <li> <b>pragma restriction( no_external_commands )</b> - disable
operating system
commands. Provides portability by ensuring no commands besides SparForte's
built-in
commands are executed. Useful for applications using SparForte as a run-time
scripting language and not for shell scripting.</li>
  <li> <b>pragma restriction( no_memcache )</b> - disable
connections to memcached.  Doesn't prevent other programs from using
Memcache.</li>
  <li> <b>pragma restriction( no_mysql_database )</b> - disable
connections to a MySQL database.  Doesn't prevent the mysql client or
other programs from using MySQL.</li>
  <li> <b>pragma restriction( no_postgresql_database )</b> - disable
connections to a PostgreSQL database.  Doesn't prevent the psql client or
other programs from using PostgreSQL.</li>
</ul>

<h4>Debugging Pragmas</h4>

<p>Interpreter directives used to investigate problems in the source
code or used with SparForte's breakout prompt.</p>

<ul>
  <li> <b>pragma assert( expression )</b> - evaluates the expression.
If it isn't true, the program stops and "assertion failed" is displayed.
Use this to check the expected results during development.
Requires --debug or --test options or asserts will have no effect.</li>
  <li> <b>pragma debug( `commands` )</b> - these are a set of
debugging commands to run when debugging mode (the --debug option)
is turned on with --debug.&nbsp; Make sure the final command ends with
a semi-colon.  Without a parameter, same as --debug (turn on debugging).
The debugging commands are run in restricted shell mode.  Because this
is a pragma, it can be placed in variable declarations or other places
executable statements are not normally allowed.</li>
  <li><span style="font-weight: bold;">pragma gcc_errors</span> - same
as --gcc-errors.&nbsp; Show simplified gcc-style errors.<br>
  </li>
  <li> <b>pragma inspect( var )</b> - show a variable's description
(as if
'env var' was used) whenever a user breaks to a command prompt. Has no
effect if --break option isn't used.</li>
  <li> <b>pragma inspection_peek</b> - like inspection_point, displaying
inspect variables, except it doesn't break to a command prompt.</li>
  <li> <b>pragma inspection_point</b> - break to a command prompt as if
SIGINT (control-C) was received, displaying the call stack and any
variables marked for inspection with pragma inspect. Has no effect if
--break option isn't used. A "breakpoint".</li>
  <li> <b>pragma test( `commands` )</b> -
these are a set of testing commands to run when test mode (the --test
option) is used.  For example, this can be used to help with unit testing.
Because this is a pragma, it can be placed in variable declarations or
other places executable statements are not normally allowed.  Make
sure the final command ends with a semi-colon.</li>
  <li> <b>pragma test_result( expression )</b> - evaluates the expression.
If it isn't true, a "test failed" message is written to standard error.
(The format of the message is affected by --gcc-errors.) Use this to check
the results in automated tests.
Requires --test option or asserts will have no effect.</li>
  <li> <b>pragma uninspect( var )</b> - undo a pragma inspect. Don't
show
a
variable's description whenever a user breaks to a command prompt. Has
no
effect if --break option isn't used.</li>
  </li>
</ul>

<h4>Documentation Pragmas</h4>

<p>Interpreter directives used to describe a project, particularily real
world concerns that are not expressed in the source code.</p>

<ul>
  <li> <b>pragma annotate( [type,] "text" )</b> - embed a comment. The
contents of any or all annotate pragmas are shown when you use the help
command on a script.  Type type of annotation field can be:
<ul>
<li><b>author</b> - who wrote the script</li>
<li><b>bugs</b> - known bugs</li>
<li><b>created</b> - when the script was first released</li>
<li><b>description</b> - a detailed description of what the script does</li>
<li><b>errors</b> - errors returned from the script</li>
<li><b>modified</b> - when the script was last modified</li>
<li><b>param</b> - description of a parameter to the script</li>
<li><b>return</b> - return value</li>
<li><b>see also</b> - a reference to another document or script</li>
<li><b>summary</b> - a short description of what the script does</li>
<li><b>todo</b> - unfinished work</li>
<li><b>version</b> - the version of the script</li>
</ul></li>
</ul>
<p>Annotations are used by the help command to produce documentation.</p>

<h4>Interfacing Pragmas</h4>

<p>Interpreter directives that affect SparForte's environment or how it 
interacts with other software.</p>

<ul>
  <li> <b>pragma export( shell | local_memcache | memcache, var )</b> - export a string variable
to the O/S environment. The first parameter must be "shell".</li>
  <li> <b>pragma import( shell | cgi | local_memcache | memcache, var )</b> -
import a variable.  For shell, from the O/S environment.  For cgi
and if pragma template/unrestricted_template was used previously,
a HTTP CGI variable from the O/S environment.  For local_memcache,
get the value of the variable from a memcached server running on
locahost port 11211.  Put the value in the SparForte variable.
If the environment variable doesn't exist, then
the SparForte will report an error (see unchecked_import).</li>
  <li><span style="font-weight: bold;">pragma no_command_hash</span> -
Bush normally remembers the location of a command once it has found
it.&nbsp; This pragma forces Bush to search for the location of the
command, ignoring the previous location.<br>
  <li> <b>pragma register_memcache_server( host, port )</b> - add a
memcache server which will be used with memcache method imports/exports</li>
  <li> <b>pragma template( css|html|js|json|text|wml|xml [, template] )</b> - SparForte
will act like a template processor (like PHP). When the script finishes
executing, SparForte will open a file called "file.tmpl" where file is the
name of the script.  If an alternate file path is included in the pragma,
that file is used as the template instead. A HTTP header is written and
SparForte parses the template along with any embedded scripts. For security,
the embedded scripts in the template will be run in a restricted shell and
with the no_external_commands restriction. Errors are shown in --gcc-errors
format using the line number in the template as the line number for the
error.  The first parameter is the template type: "css" (a style sheet),
"html" (HTML web page), "js" (Javascript script), "json" (JSON encoded
text), "text" (plain text), "wml" (WML text) or "xml" (XML text).</li>
  <li> <b>pragma unchecked_import( shell | cgi | local_memcache | memcache, var )</b> -
import a variable.  For shell, from the O/S environment.  For cgi
and if pragma template/unrestricted_template was used previously,
a HTTP CGI variable from the O/S environment.  For local_memcache,
get the value of the variable from a memcached server running on
locahost port 11211.  Put the value in the SparForte variable.
If the environment variable doesn't exist, then
the SparForte variable is unchanged.</li>
  <li> <b>pragma unrestricted_template( css|html|js|json|text|wml|xml [, template] )</b> -
SparForte will act like a template processor (like PHP). This pragma is
the same as pragma template except that the embedded scripts are executed
in a normal shell with no security restrictions.  The type parameter
is described under pragma template.</li>
  <li> <b>pragma volatile( var )</b> - the variable is assumed to be
an variable which may change unexpectedly during the script's execution.
The variable's value will be updated each time it is referenced in an
expression. Has no effect unless the variable is imported as well.</li>
</ul>

<h4>Miscellaneous Pragmas</h4>

<p>Interpreter directives that don't fit in any other category.</p>

<ul>
  <li> <b>pragma prompt_script( `commands` )</b> - commands to draw
the command prompt.&nbsp; If the string is an empty string, the default "=&gt;"
prompt
is used.&nbsp; Make sure the final command ends with a
semi-colon.&nbsp; Changing your prompt will also change the title of
your terminal window.<br>
  </li>
</ul>

<h3>Shell Variables</h3>

<p>UNIX-like operating systems have environment variables.  These are
variables that the operating system assign to your running program.</p>

<p>You can also read environment variables using the command_line package.</p>

<h4>Importing Shell Environment Variables</h4>

<p>Normally, SparForte will not copy your environment variables into
SparForte.  Instead, you request the variables using <b>pragma import</b>.
SparForte will examine the environment variables and, if it finds one
with the same name, the SparForte variable will have the same value
as the environment variable.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; JAVA_HOME : string<br>
		=&gt; <b>pragma</b> import( shell, JAVA_HOME )<br>
		=&gt; ? JAVA_HOME<br>
		/usr/lib64/jvm/java<br>&nbsp;<br></p>
        <div class="code_caption">
                <b>Example</b>: Importing an environment variable on the command line</span>
        </div>
        </div>
        </center>

<p>A few variables are automatically imported when SparForte runs.  These
variables are needed for the proper functioning of the shell (for
example, HOME).  You can also use the <b>--import-all</b> command line
option to import all the environment variables.  However, --import-all is
meant to be a convenience or debugging tool: it is a better technique to
import only what your script needs to run.</p>

<p>You can examine a variable with <b>env</b> to see if it is imported
or exported.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; <b>env</b> HOME<br>
		HOME := "/home/ken"; -- imported shell environment identifier of the type string
		</p>
        </div>
        </center>

<p>If the variable doesn't exist, SparForte will report an error.
This behaviour can be overridden using <b>pragma unchecked_import</b>:
if the variable doesn't exist in the environment, the value will
be unchanged.  It is a good idea to assign a default value.</p>

<p>If you are using SparForte as your login shell, there is nothing
to import: there's no previous shell to import variable from to
put them into SparForte.</p>

<h4>Exporting Shell Environment Variables</h4>

<p>To make your Sparforte variables visble to other programs, such
as external commands, you must export the variable into the
operating system environment variables with <b>pragma export</b>.
This exporting process occurs whenever an external command is
executed, the standard technique in shells.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; JAVA_HOME : string := "/usr/lib64/jvm/java"<br>
		=&gt; <b>pragma</b> export( shell, JAVA_HOME )<br>
		=&gt; eclipse &amp; -- a command that needs JAVA_HOME<br>
		</p>
        </div>
        </center>

<p>If you use SparForte as your login shell, variables like JAVA_HOME can
be set up in your SparForte profile file so they are created and exported
whenever you log in.</p>

<h4>Both Importing and Exporting, and Volatile Shell Environment Variables</h4>

<p>Environment variables can be both imported and exported by using
both pragmas.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; DISPLAY : string;<br>
		=&gt; <b>pragma</b> import( shell, DISPLAY )<br>
		=&gt; <b>pragma</b> export( shell, DISPLAY )<br>
		=&gt; <b>env</b> DISPLAY<br>
		DISPLAY := ":0.0"; -- imported exported shell environment identifier of the type string<br>&nbsp;<br>
		</p>
        <div class="code_caption">
                <b>Example</b>: Importing and Exporting the X Windows DISPLAY variable</span>
        </div>
        </div>
        </center>

<p><b>Pragma volatile</b> will mark a variable as "volatile", meaning that its
value can change unexpectedly and SparForte should reload the value from the
environment whenever it is referenced.  Although you can make volatile
environment variables, it probably won't be useful: these variables are owned
by the running process, which is SparForte, so it is virtually impossible
to change their values except using the SparForte itself.</p>

<h3>CGI Variables</h3>

<p>CGI variables are the HTTP FORM tag variables submitted from a web
page.  If you are in a web template (if you used <b>pragma template</b> or
<b>pragma unrestricted_template</b>), you can read the variables using
<b>pragma import</b>.</p>

<p>If the variable doesn't exist, SparForte will report an error.
This behaviour can be overridden using <b>pragma unchecked_import</b>:
if the variable doesn't exist in the environment, the value will
be unchanged.  It is a good idea to assign a default value.</p>

<p>You cannot export CGI variables: there's nowhere to export the values
to.</p>

<p><b>Pragma volatile</b> can be used, but like shell variables, it
has no meaningful effect: the CGI variables will not change while in
a template.</p>

<p>You can also read CGI variables using the CGI package.</p>

<h3>Local Memcache Variables</h3>

<p><b>Memcached</b> (or the Memcache Daemon) is a general-purpose
networked memory caching system that
was originally developed by Danga Interactive for LiveJournal, but is now
used by many other sites. It is often used to speed up dynamic
database-driven websites by caching data and objects in RAM to reduce the
number of times an external data source (such as a database or API) must
be read.  Memcached has been used by web sites including YouTube,
Facebook and Twitter.</p>

<p>SparForte supports memcached natively (that is, you don't need to
use a special package to access memcached.)
The memcached support is built on the PegaSoft <b>PegaSock</b>
socket library, which supports local memcached caching as well as
distributed, redundant memcached caching clusters.</p>

<p>One important rule: PegaSock expects a non-empty string for all
variable values (it uses an empty string to represent a cache miss.)</p>

<p>When importing or exporting to local_memcache, the variables will be
imported or exported from your local machine.  SparForte expects to
find a memcached server running on <b>localhost and port 11211</b> (the default
memcached port).</p>

<p>All SparForte scripts running on the same server can access the
memcache variables.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; s : string := "test"<br>
		=&gt; <b>pragma</b> export( local_memcache, s )<br>
		=&gt; <b>env</b> s<br>
		s := "test"; -- exported local memcache identifier of the type string<br>
		=&gt; <b>unset</b> s<br>
		=&gt; s : string := "not test"<br>
		=&gt; <b>pragma</b> import( local_memcache, s )<br>
		=&gt; ? s<br>
		test<br>&nbsp;<br>
                </p>
        <div class="code_caption">
                <b>Example</b>: A simple command line example of local_memcache</span>
        </div>
        </div>
	</center>

<h4>Importing with Memcache</h4>

<p>When importing, The variable will be read from memcache when <b>pragma
import</b> is used.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; user_count : string<br>
		=&gt; <b>pragma</b> import( local_memcache, user_count )<br>
		=&gt; <b>env</b> user_count<br>
		user_count := " 3"; -- imported local memcache identifier of the type string<br>&nbsp;<br>
        <div class="code_caption">
                <b>Example</b>: Importing a memcached variable on the command line</span>
        </div>
        </div>
        </center>

<p>(For example, if you import a variable named "user_count", SparForte
will request the value of "user_count" from memcached hash table on
the localhost using a memcached GET command.)</p>

<p>If the variable doesn't exist, SparForte will report an error.
This behaviour can be overridden using <b>pragma unchecked_import</b>:
if the variable doesn't exist in the environment, the value will
be unchanged.  It is a good idea to assign a default value.</p>

<p>The variable will normally be read at the time of importing,
though this behaviour can be changed with pragam volatile (see below).</p>

<p>You can use a <b>declare block</b> to get the value at your discretion
by using an imported variable.</p>

        <center>
        <div class="code">
                <p class="code">
		<b>declare</b><br>
        	&nbsp;&nbsp;-- Get current value from memcached<br>
    		&nbsp;&nbsp;status : string;<br>
    		&nbsp;&nbsp;<b>pragma</b> import( local_memcache, status );<br>
  		<b>begin</b><br>
    		&nbsp;&nbsp;-- do something with status<br>
  		<b>end</b>;<br>&nbsp;<br>
                </p>
        <div class="code_caption">
                <b>Example</b>: Using declare to import on demand</span>
        </div>
        </div>
        </center>

<h4>Exporting with Memcache</h4>

<p>When exporting, the variable's final value will be stored in memcache
with the memcache SET command when the varible goes out of scope or
is destroyed with unset.</p>

<p>You can update the value at any time using a declare block and an
exported variable:</p>

        <center>
        <div class="code">
                <p class="code">
  		new_status_value := "good";<br>
  		<b>declare</b><br>
    		&nbsp;&nbsp;-- Push out new value to memcached<br>
    		&nbsp;&nbsp;status : string := new_status_value;<br>
    		&nbsp;&nbsp;<b>pragma</b> export( local_memcache, status );<br>
  		<b>begin</b><br>
    		&nbsp;&nbsp;<b>null</b>; -- do nothing<br>
  		<b>end</b>; -- before discarding status, write it to memcached<br>&nbsp;<br>
                </p>
        <div class="code_caption">
                <b>Example</b>: Using declare to export on demand</span>
        </div>
        </div>
        </center>

<h4>Importing, Exporting and Volatile with Memcache</h4>

<p>It is possible to declare a variable as both imported and
exported using both import/export pragmas.</p>

<p><b>Pragma volatile</b> will mark a variable as "volatile", meaning that its
value can change unexpectedly and SparForte should reload the value from the
memcached whenever it is referenced.</p>

<p>You can declare a variable as import, export and volatile.
For example:</p>

        <center>
        <div class="code">
                <p class="code">
		<b>declare</b><br>
		&nbsp;&nbsp;user_count : string;<br>
		&nbsp;&nbsp;<b>pragma</b> import( local_memcache, user_count );<br>
		&nbsp;&nbsp;<b>pragma</b> export( local_memcache, user_count );<br>
		&nbsp;&nbsp;<b>pragma</b> volatile( user_count );<br>
		<b>begin</b><br>
		-- do some other work here<br>
		&nbsp;&nbsp;user_count := strings.image( integer( numerics.value( @ ) + 1 ) );<br>
  		<b>end</b></b>;<br>&nbsp;<br>
                </p>
        <div class="code_caption">
                <b>Example</b>: Using import, export and volatile</span>
        </div>
        </div>
        </center>

<p>In this example, the assignment statement will get the latest value for
user_count, convert it to a number, add 1 and convert the result back to
a string.  When the declare block ends, the value of user_count will be
stored in memcached.</p>

<p>Bear in mind that this kind of operation is not atomic: another script
could try to update user_count in memcache before the first script
can write the result.  If you want to lock access to the variable to
guarantee exclusive access, you will need to use the lock_file package
or a similar approach.</p>

<h4>Handling Server Failures</h4>

<p>PegaSock uses a countdown system when a memcache server cannot
be found.  If it cannot connect, it marks the server as off-line
and will return cache misses for several commands.  After enough
commands have passed, it will attempt to reconnect to memcached.
These "back offs" are escallating: each failed reconnect attempt
will result in a longer backoff period.  This is done for
performance reasons: establishing new network connections is a
very slow operation.</p>

<p>If you don't have memcached running on your local machine, it
will have the same effect.</p>

<p>You'll periodically see warning messages from PegaSock because
it is unable to establish a connection.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; s : string<br>
		=&gt; <b>pragma</b> import( local_memcache, s )<br>
		pegasock-memcache.adb:81: server localhost 11211 error - backing off for 8 tries<br>&nbsp;<br>
</p>
        <div class="code_caption">
                <b>Example</b>: The memcached server is not running or cannot be accessed</span>
        </div>
        </div>
        </center>

<h3>Distributed Memcache Variables</h3>

<p>If you have memcached running on two or more servers, you can create a
redundant distributed cache using the "memcache" method instead of
"local_memcache".
In order to use a distributed cache, inform SparForte of what servers to
use with pragma register_memcache_server.</p>

        <center>
        <div class="code">
                <p class="code">
		=&gt; <b>pragma</b> register_memcache_server( "cachehost1", 11211 );<br>
		=&gt; <b>pragma</b> register_memcache_server( "cachehost2", 11211 );<br>
		=&gt; company_name : string<br>
		=&gt; <b>pragma</b> import( memcache, company_name )<br>
		=&gt; ? company_name<br>
		PegaSoft Canada<br>
		=&gt; <b>env</b> company_name<br>
		company_name := "PegaSoft Canada"; -- imported memcache identifier of the type string<br>&nbsp;<br></p>
        <div class="code_caption">
                <b>Example</b>: Importing a variable stored on two hosts</span>
        </div>
        </div>
        </center>

<p>With more than one server, SparForte will store the variable on two servers.
If one server should fail, it wil retrieve the variable value from the other.</p>

<h3>Managing Script Licenses</h3>

<p>Tracking and keeping accurate information about licenses is important for
large companies and organizations.  Such groups may run third-party license
management software which scans source code and tries to guess at what license
applies.  However, typos and copying errors putting license info into comments
makes this an imperfect task.  Software may be bundled together with multiple
licenses.  Licenses are further qualified by server limits,
user limits, evaluation periods or other real world or legal concerns.</p>

<p>SparForte can help manage licenses with the license pragma.  This pragma
declares the license for a script in a structured way.  This approach assists
in automating license compliance, helps to make the best use of licenses while
reducing the risk from a license audit.  Since there are thousands
of licenses, SparForte doesn't attempt to know, enforce or reconcile every
license&mdash;it leaves these concerns for specialized license software.
However, many of the most popular licenses are known by SparForte.</p>

<p>For example, if myscript.sp contains this pragma:</p>

	<center>
        <div class="code">
	<b>pragma</b> license( public_domain );<br>
	</div>
	</center>

<p>then you can use the help command to see the license without running the script.</p>

	<center>
        <div class="code">
	$ spar -e "help -l myscript.sp;"<br>
	public_domain<br>
	</div>
	</center>

<p>If you use license management software, configure it to run the spar help
command to get an accurate license name.</p>

<p>If you have a commercial license, declare it as commercial and include
more details in the second parameter, or use the second parameter as a
URL to the text of the license.</p>

	<center>
        <div class="code">
	<b>pragma</b> license( commercial, "bogodb license" );<br>
	</div>
	</center>

<p>The help command will show the license with the additional text.</p>

	<center>
        <div class="code">
	$ spar -e "help -l myscript.sp;"<br>
	commercial: bogodb license<br>
	</div>
	</center>

<p>A script may only have one license pragma.</p>

<p>Other examples:</p>

	<center>
        <div class="code">
	<b>pragma</b> license( gpl );<br>
	<b>pragma</b> license( freeware, "2 week evaluation" );<br>
	<b>pragma</b> license( gplv2, "LGPL" );<br>
	<b>pragma</b> license( commercial, "bogodb license: 15 users" );<br>
	</div>
	</center>

<p>Running scripts may check the license string with System.Script_License.</p>

	<center>
        <div class="code">
	=&gt; <b>pragma</b> license(bsd_original)<br>
	=&gt; ? System.Script_License<br>
	bsd_original<br>
	</div>
	</center>

&nbsp;<br>
			</td>
			<td bgcolor="#d3c7f8" width="150" align="right" valign="top"><noscript><hr /></noscript><img src="art/right_menu_top.png" width="150" height="24" alt="[Right Submenu]"><br><a name="submenu"></a>
                                <p class="rmt"><a class="rightmenutext" href="ref_adascript.html">&nbsp;AdaScript versus GCC</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_case.html">&nbsp;Case Sensitivity</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_reserved.html">&nbsp;Reserved Words</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_comments.html">&nbsp;Comments</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_literals.html">&nbsp;Literals</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_shellargs.html">&nbsp;Bourne Shell Word Expansions</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_types.html">&nbsp;Fundamental Types</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_typedecl.html">&nbsp;User-defined Types</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_enum.html">&nbsp;Enumerated Types</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_arrays.html">&nbsp;Arrays</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_records.html">&nbsp;Records</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_assign.html">&nbsp;Basic Assignment</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_specials.html">&nbsp;The @ and % Operands</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_cmdlineargs.html">&nbsp;Command Argument Shortcuts</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_redirection.html">&nbsp;Redirection and Pipelines</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_cmdline.html">&nbsp;Command Line Interaction</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_shellcmds.html">&nbsp;Built-in Shell Commands</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_cd.html">&nbsp;The Current Directory</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_db.html">&nbsp;Database Commands</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_flow.html">&nbsp;Flow of Control</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_other.html">&nbsp;Other Statements/ Subprograms</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_extcmds.html">&nbsp;External Commands</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_subprograms.html">&nbsp;Block Statements and Subprograms</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_sockets.html">&nbsp;TCP/IP Sockets</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_numberformat.html">&nbsp;Numeric Formatting with Put</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_pragmas.html">&nbsp;<b>Interpreter Directives</b></a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_cmdoptions.html">&nbsp;Command Line Options</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_cmdref.html">&nbsp;Command Reference</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_charsets.html">&nbsp;ASCII and Latin_1 Character Sets</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_errors.html">&nbsp;Common Error Messages</a></p>
                                <p class="rmt"><a class="rightmenutext" href="ref_php.html">&nbsp;Common PHP Functions and the SparForte Equivalent</a></p>
			</td>

		</tr>
		<tr>
			<td bgcolor="#d3c7f8" align="left" valign="middle"><a href="#top"><img src="art/up_arrow.png" width="24" height="27" border="0" alt="[Back to Top]"><span>&nbsp;Back To Top</span></a></td>
			<td bgcolor="#d3c7f8" align="center" valign="middle"><img src="art/forte_small.png" width="26" height="32" border="0" alt="[Small Forte Symbol]"></td>
	       	</tr>

	</table>

</body>
</html>

